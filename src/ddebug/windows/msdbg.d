// File generated by idl2d from
//   msdbg.idl
//module sdk.win32.msdbg;
module ddebug.windows.msdbg;

version(Windows):
version(USE_MAGO):


//import sdk.port.base;
public import win32.windows;
public import win32.wtypes;
public import win32.oaidl;
public import win32.ocidl;
public import win32.objidl;
public import win32.objbase;
//import ddebug.windows.servprov;

// msdbg.idl : Microsoft Debug API

// notes:
//
// - define AD7_NO_LIB to exclude library statement
// - define AD7_NO_ENC to exclude ENC interfaces

//import win32.ocidl;

//public import sdk.win32.ocidl;
//public import sdk.port.oleidl;
//public import sdk.port.basetsd; 
 // _BASETSD_H_

version(pp_ifdef) /* #ifdef VS_IDL_BUILD */ {
// Just to get rup
public import sdk.port.sdk_version;
} 

const DWORD MSDBG_VERSION = 7126;

// Use uuid_constant to keep the specified guid constant. This is a note that this guid must be kept constant.
// #define uuid_constant uuid

// Use uuid_jdate to embed the jdate in the GUID
// #define uuid_jdate(first, jdate, last) uuid_constant(first-jdate-last)

version(pp_ifdef) /* #ifdef BUILDING_DEBUGGGER_IDL_MAKEAPI */ {
public import sdk.port.ad7.hrc;
} 

/+ interface IDebugCoreServer2; +/
/+ interface IDebugCoreServer3; +/
/+ interface IDebugPortSupplier2; +/
/+ interface IDebugPort2; +/
/+ interface IDebugPortNotify2; +/
/+ interface IDebugPortRequest2; +/
/+ interface IDebugSession2; +/
/+ interface IDebugSession3; +/
/+ interface IDebugEngine2; +/
/+ interface IDebugEngine3; +/
/+ interface IDebugEventCallback2; +/
/+ interface IDebugEvent2; +/
/+ interface IDebugProcess2; +/
/+ interface IDebugProgram2; +/
/+ interface IDebugProgramNode2; +/
/+ interface IDebugThread2; +/
/+ interface IDebugThread3; +/
/+ interface IDebugLogicalThread2; +/
/+ interface IDebugStackFrame2; +/
/+ interface IDebugMemoryContext2; +/
/+ interface IDebugCodeContext2; +/
/+ interface IDebugMemoryBytes2; +/
/+ interface IDebugDisassemblyStream2; +/
/+ interface IDebugDocumentContext2; +/
/+ interface IDebugExpressionContext2; +/
/+ interface IDebugBreakpointRequest2; +/
/+ interface IDebugBreakpointResolution2; +/
/+ interface IDebugBoundBreakpoint2; +/
/+ interface IDebugPendingBreakpoint2; +/
/+ interface IDebugErrorBreakpoint2; +/
/+ interface IDebugExpression2; +/
/+ interface IDebugModule2; +/
/+ interface IDebugModule3; +/
/+ interface IDebugDocument2; +/
/+ interface IDebugDocumentText2; +/
/+ interface IDebugDocumentPosition2; +/
/+ interface IDebugFunctionPosition2; +/
/+ interface IDebugDocumentTextEvents2; +/
/+ interface IDebugSimpleProperty2; +/
/+ interface IDebugMDMUtil2_V7; +/
/+ interface IDebugReference2; +/
/+ interface IDebugProperty2; +/
/+ interface IDebugExceptionCallback2; +/
/+ interface IEnumDebugProcesses2; +/
/+ interface IEnumDebugPrograms2; +/
/+ interface IEnumDebugThreads2; +/
/+ interface IEnumDebugStackFrames2; +/
/+ interface IEnumDebugCodeContexts2; +/
/+ interface IEnumDebugBoundBreakpoints2; +/
/+ interface IEnumDebugPendingBreakpoints2; +/
/+ interface IEnumDebugErrorBreakpoints2; +/
/+ interface IEnumDebugExceptionInfo2; +/
/+ interface IEnumDebugFrameInfo2; +/
/+ interface IEnumDebugFrameInfoFilter2; +/
/+ interface IEnumDebugMachines2__deprecated; +/
/+ interface IEnumCodePaths2; +/
/+ interface IEnumDebugModules2; +/
/+ interface IEnumDebugPortSuppliers2; +/
/+ interface IEnumDebugPorts2; +/
/+ interface IEnumDebugReferenceInfo2; +/
/+ interface IEnumDebugPropertyInfo2; +/

/+ interface IDebugProgramPublisher2; +/
/+ interface IDebugProgramProvider2; +/
/+ interface IDebugProviderProgramNode2; +/ 

version(pp_ifdef) /* #ifdef AD7_NO_ENC */ {
alias IUnknown IDebugENCUpdate;
} else {

//public import ddebug.windows.enc;
} 

// #define IDebugMachine2_V7 IDebugCoreServer2

extern GUID guidVBLang;
extern GUID guidVBScriptLang;
extern GUID guidJScriptLang;
extern GUID guidCLang;
extern GUID guidCPPLang;
extern GUID guidSQLLang;
extern GUID guidScriptLang;
extern GUID guidSafeCLang;
extern GUID guidJSharpLang;
extern GUID guidManagedCLang;
extern GUID guidManagedCPPLang;
extern GUID guidCausalityBreakpointLang;
extern GUID guidFortranLang;
extern GUID guidMethodIdLang;
extern GUID guidClientScriptLang;

extern GUID guidScriptEng;
extern GUID guidSQLEng;
extern GUID guidCOMPlusNativeEng;
extern GUID guidCOMPlusOnlyEng;
extern GUID guidNativeOnlyEng;
extern GUID guidMsOrclEng;
extern GUID guidEmbeddedCLREng;
extern GUID guidSQLEng2;
extern GUID guidCOMPlusSQLLocalEng;
extern GUID guidCOMPlusSQLRemoteEng;
extern GUID guidSilverlightEng;
extern GUID GUID_WorkflowDebugEngine;
extern GUID guidMACSilverlightEng;
extern GUID guidCoreSystemClrEng;

extern GUID guidMicrosoftVendor;

// Port suppliers
extern GUID guidLocalPortSupplier;
extern GUID guidNativePortSupplier;
extern GUID guidNativePipePortSupplier;
extern GUID guidEmbeddedCLRPortSupplier;

// IDebugProperty2 GUID filters
extern GUID guidFilterLocals;
extern GUID guidFilterAllLocals;
extern GUID guidFilterArgs;
extern GUID guidFilterLocalsPlusArgs;
extern GUID guidFilterAllLocalsPlusArgs;
extern GUID guidFilterRegisters;
extern GUID guidFilterThis;
extern GUID guidFilterAutoRegisters;

// GUIDs for GetExtendedInfo
// GUIDs for GetExtendedInfo
extern GUID guidDocument;
// TODO: remove this one once everyone implements IDebugProperty2::GetMemoryContext
extern GUID guidCodeContext;
extern GUID guidCustomViewerSupported;
extern GUID guidSimpleGridViewer;

extern GUID guidExtendedInfoSlot;
extern GUID guidExtendedInfoSignature;

// Document checksum algorithms
extern GUID guidSourceHashMD5;
extern GUID guidSourceHashSHA1;

// Other GUIDs
extern GUID guidMDANotification;

enum /+ enum_GETNAME_TYPE+/ : DWORD 
{
    GN_NAME,                // Gets the (as friendly as possible) name of the document or context
    GN_FILENAME,            // Gets the full path file name (drive+path+filename+ext or as much as possible) of the document or context
    GN_BASENAME,            // Gets the basename+ext part of the file name
    GN_MONIKERNAME,            // Gets the unique, monikerized name of the document or context
    GN_URL,                    // Gets the URL name of the document or context
    GN_TITLE,                // Gets the title of the document if possible.
    GN_STARTPAGEURL,
}
alias DWORD enum_GETNAME_TYPE;
alias DWORD GETNAME_TYPE;

enum /+ enum_TEXT_POSITION_MAX+/ : int 
{
    TEXT_POSITION_MAX_LINE        = 0xffffffff,
    TEXT_POSITION_MAX_COLUMN    = 0xffffffff,
}
alias int enum_TEXT_POSITION_MAX;

struct _tagTEXT_POSITION
{
    DWORD dwLine;
    DWORD dwColumn;
}
alias _tagTEXT_POSITION TEXT_POSITION;

struct tagBSTR_ARRAY
{
    DWORD dwCount;
    /+[size_is(dwCount)]+/ BSTR *Members;
}
alias tagBSTR_ARRAY BSTR_ARRAY;

struct tagCONST_GUID_ARRAY
{
    DWORD dwCount;
    /+[size_is(dwCount)]+/ const( GUID)*Members;
}
alias tagCONST_GUID_ARRAY CONST_GUID_ARRAY;

struct tagGUID_ARRAY
{
    DWORD dwCount;
    /+[size_is(dwCount)]+/ GUID *Members;
}
alias tagGUID_ARRAY GUID_ARRAY;

// ------------------------------------------------------------------
// IDebugCoreServer2
const GUID IID_IDebugCoreServer2 = IDebugCoreServer2.iid;

interface IDebugCoreServer2 : IUnknown
{
    static const GUID iid = { 0x17bf8fa3,0x4c5a,0x49a3,[ 0xb2,0xf8,0x59,0x42,0xe1,0xea,0x28,0x7e ] };

    HRESULT GetMachineInfo(
        in MACHINE_INFO_FIELDS Fields,
        /+[out]+/ MACHINE_INFO* pMachineInfo);

    HRESULT GetMachineName(
        /+[out]+/ BSTR* pbstrName);

    // Get a port supplier that exists on this machine
    HRESULT GetPortSupplier(
        in GUID* guidPortSupplier,
        /+[out]+/ IDebugPortSupplier2 * ppPortSupplier);

    // Get a port that already exists on this machine
    HRESULT GetPort(
        in GUID* guidPort,
        /+[out]+/ IDebugPort2 * ppPort);

    // Enum all the ports on this machine
    HRESULT EnumPorts(
        /+[out]+/ IEnumDebugPorts2 * ppEnum);

    // Enum all the port suppliers on this machine
    HRESULT EnumPortSuppliers(
        /+[out]+/ IEnumDebugPortSuppliers2 * ppEnum);

    HRESULT GetMachineUtilities_V7(
        /+[out]+/ IDebugMDMUtil2_V7 * ppUtil);
}
enum /+ enum_MACHINE_INFO_FLAGS+/ : DWORD 
{
        MCIFLAG_TERMINAL_SERVICES_AVAILABLE    = 0x00000001,
}
alias DWORD enum_MACHINE_INFO_FLAGS;
alias DWORD MACHINE_INFO_FLAGS;
enum /+ enum_MACHINE_INFO_FIELDS+/ : DWORD 
{
        MCIF_NAME            = 0x00000001,
        MCIF_FLAGS            = 0x00000002,

        MCIF_ALL            = 0x00000003,
}
alias DWORD enum_MACHINE_INFO_FIELDS;
alias DWORD MACHINE_INFO_FIELDS;
struct tagMACHINE_INFO
{
        // Valid fields
        MACHINE_INFO_FIELDS    Fields;
        // Machine name
        BSTR                bstrName;
        // Flags
        MACHINE_INFO_FLAGS    Flags;
}
alias tagMACHINE_INFO MACHINE_INFO;;

const GUID IID_IDebugCoreServer3 = IDebugCoreServer3.iid;

interface IDebugCoreServer3 : IDebugCoreServer2
{
    static const GUID iid = { 0x12c1180e,0xc257,0x4485,[ 0x98,0x00,0xaf,0x48,0x4b,0x69,0x97,0x13 ] };

    HRESULT GetServerName(
        /+[out]+/ BSTR *pbstrName);

    HRESULT GetServerFriendlyName(
        /+[out]+/ BSTR *pbstrName);        

    HRESULT EnableAutoAttach(
        /+[ size_is (celtSpecificEngines), ptr]+/ in GUID* rgguidSpecificEngines,
        in DWORD celtSpecificEngines,
        /+[ ptr]+/ in LPCOLESTR pszStartPageUrl,
        /+[out]+/ BSTR* pbstrSessionId);

    HRESULT DiagnoseWebDebuggingError(
        /+[ ptr]+/ in LPCWSTR pszUrl);

    HRESULT CreateInstanceInServer(
        /+[ ptr]+/ in LPCWSTR szDll,
        in WORD wLangId,
        in CLSID* clsidObject,
        in IID* riid,
        /+[out, iid_is(riid)]+/ void **ppvObject);

    HRESULT QueryIsLocal(
        );

    HRESULT GetConnectionProtocol(
        /+[out]+/ CONNECTION_PROTOCOL *pProtocol);

    HRESULT DisableAutoAttach(
        );
}
enum /+ tagCONNECTION_PROTOCOL+/
{
        CONNECTION_NONE = 0,
        CONNECTION_UNKNOWN = 1,
        CONNECTION_LOCAL = 2,
        CONNECTION_PIPE = 3,
        CONNECTION_TCPIP = 4,
        CONNECTION_HTTP = 5,
        CONNECTION_OTHER = 6
}
alias int tagCONNECTION_PROTOCOL;
alias int CONNECTION_PROTOCOL;;

// ------------------------------------------------------------------
// IDebugMachine2_V7
//
// This interface has been renamed since more than one remote debugging
// host (msvsmon) can be running on a machine
// #define IDebugMachine2_V7 IDebugCoreServer2
alias IID_IDebugCoreServer2 IID_IDebugMachine2_V7;

// ------------------------------------------------------------------
// IDebugMachineEx2_V7
// This interface was added after the Office 10 Fork
const GUID IID_IDebugMachineEx2_V7 = IDebugMachineEx2_V7.iid;

interface IDebugMachineEx2_V7 : IUnknown
{
    static const GUID iid = { 0xae27b230,0xa0bf,0x47ff,[ 0xa2,0xd1,0x22,0xc2,0x9a,0x17,0x8e,0xac ] };
    HRESULT EnableAutoAttachOnProgramCreate(
        in LPCWSTR pszProcessNames,   // process names seperated by semicolons ex: "foo.exe;bar.exe;bigname.exe"
        in GUID* guidEngine,        // auto attach when 'guidEngine' is added to the process, use GUID_NULL for 'any engine'
        in LPCWSTR pszSessionId,      // session id to attach to
        /+[out]+/ DWORD* pdwCookie);        // cookie returned that is used to call 'DisableAutoAttachOnEvent'

    HRESULT DisableAutoAttachOnEvent(
        in DWORD dwCookie);

    // Get a port supplier that exists on this machine
    HRESULT GetPortSupplierEx(
        in LPCOLESTR wstrRegistryRoot,
        in GUID* guidPortSupplier,
        /+[out]+/ IDebugPortSupplier2 * ppPortSupplier);

    // Get a port that already exists on this machine
    HRESULT GetPortEx(
        in LPCOLESTR wstrRegistryRoot,
        in GUID* guidPort,
        /+[out]+/ IDebugPort2 * ppPort);

    // Enum all the ports on this machine
    HRESULT EnumPortsEx(
        in LPCOLESTR wstrRegistryRoot,
        /+[out]+/ IEnumDebugPorts2 * ppEnum);

    // Enum all the port suppliers on this machine
    HRESULT EnumPortSuppliersEx(
        in LPCOLESTR wstrRegistryRoot,
        /+[out]+/ IEnumDebugPortSuppliers2 * ppEnum);
};

// --------------------------------------------------------
// IDebugPortSupplier2

const GUID IID_IDebugPortSupplier2 = IDebugPortSupplier2.iid;

interface IDebugPortSupplier2 : IUnknown
{
    static const GUID iid = { 0x53f68191,0x7b2f,0x4f14,[ 0x8e,0x55,0x40,0xb1,0xb6,0xe5,0xdf,0x66 ] };
    HRESULT GetPortSupplierName(
        /+[out]+/ BSTR* pbstrName);

    HRESULT GetPortSupplierId(
        /+[out]+/ GUID* pguidPortSupplier);

    // Get a port from this port supplier
    HRESULT GetPort(
        in GUID* guidPort,
        /+[out]+/ IDebugPort2 * ppPort);

    // Enum the ports that already exist
    HRESULT EnumPorts(
        /+[out]+/ IEnumDebugPorts2 * ppEnum);

    // Does this port supplier support adding new ports? S_OK == yes; S_FALSE == no
    HRESULT CanAddPort();

    // Add a port
    HRESULT AddPort(
        /+[in]+/ IDebugPortRequest2 pRequest,
        /+[out]+/ IDebugPort2 * ppPort);

    // Remove a port
    HRESULT RemovePort(
        /+[in]+/ IDebugPort2 pPort);
};

// --------------------------------------------------------
// IDebugPortSupplier3
const GUID IID_IDebugPortSupplier3 = IDebugPortSupplier3.iid;

interface IDebugPortSupplier3 : IDebugPortSupplier2
{
    static const GUID iid = { 0x5b5eec44,0x51aa,0x4210,[ 0xb8,0x4f,0x19,0x38,0xb8,0x57,0x6d,0x8d ] };
    // Can the port supplier remember new ports? S_OK == yes; S_FALSE == no
    HRESULT CanPersistPorts();
    
    // Enum the ports that the SDM remembered for the port supplier
    HRESULT EnumPersistedPorts(
        in BSTR_ARRAY PortNames,
        /+[out]+/ IEnumDebugPorts2 * ppEnum);
};

// --------------------------------------------------------
// IDebugPortPicker
const GUID IID_IDebugPortPicker = IDebugPortPicker.iid;

interface IDebugPortPicker : IUnknown
{
    static const GUID iid = { 0x8d6eed60,0x2737,0x4425,[ 0xb3,0x8a,0x49,0x0e,0xf2,0x73,0xac,0xbb ] };
    // SetSite() will be called before any other methods are called
    HRESULT SetSite(/+[in]+/ IServiceProvider  pSP);

    // Display a dialog that allows the user to select a port.
    // A return value of S_FALSE (or a return value of S_OK with the
    // BSTR set to NULL) indicates that the user canceled the dialog.
    HRESULT DisplayPortPicker(
        in HWND hwndParentDialog,
        /+[out]+/ BSTR* pbstrPortId);
};

// --------------------------------------------------------
// IDebugPortSupplierDescription2
const GUID IID_IDebugPortSupplierDescription2 = IDebugPortSupplierDescription2.iid;

interface IDebugPortSupplierDescription2 : IUnknown
{
    static const GUID iid = { 0xd0785faa,0x91d7,0x4ca2,[ 0xa3,0x02,0x65,0x55,0x48,0x77,0x19,0xf7 ] };

    // Get an extended description of the port supplier
    HRESULT GetDescription(
        /+[out]+/ PORT_SUPPLIER_DESCRIPTION_FLAGS *pdwFlags,
        /+[out]+/ BSTR *pbstrText
        );
}
enum /+ enum_PORT_SUPPLIER_DESCRIPTION_FLAGS+/ : DWORD 
{
        PSDFLAG_SHOW_WARNING_ICON    = 0x00000001
}
alias DWORD enum_PORT_SUPPLIER_DESCRIPTION_FLAGS;
alias DWORD PORT_SUPPLIER_DESCRIPTION_FLAGS;;

// --------------------------------------------------------
// IDebugPort2

const GUID IID_IDebugPort2 = IDebugPort2.iid;

interface IDebugPort2 : IUnknown
{
    static const GUID iid = { 0x79293cc8,0xd9d9,0x43f5,[ 0x97,0xad,0x0b,0xcc,0x5a,0x68,0x87,0x76 ] };

    HRESULT GetPortName(
        /+[out]+/ BSTR* pbstrName);

    HRESULT GetPortId(
        /+[out]+/ GUID* pguidPort);

    // Get the request used to create this port (if available)
    HRESULT GetPortRequest(
        /+[out]+/ IDebugPortRequest2 * ppRequest);

    // Get the port supplier that supplied this port
    HRESULT GetPortSupplier(
        /+[out]+/ IDebugPortSupplier2 * ppSupplier);

    // Get an IDebugProcess2 for a PID running on this port
    HRESULT GetProcess(
        in AD_PROCESS_ID ProcessId,
        /+[out]+/ IDebugProcess2 * ppProcess);

    // Enum all the processes running on this port
    HRESULT EnumProcesses(
        /+[out]+/ IEnumDebugProcesses2 * ppEnum);
}
enum /+ enum_AD_PROCESS_ID+/ : DWORD 
{
        AD_PROCESS_ID_SYSTEM,
        AD_PROCESS_ID_GUID
}
alias DWORD enum_AD_PROCESS_ID;
alias DWORD AD_PROCESS_ID_TYPE;
union AD_PROCESS_ID /+switch(AD_PROCESS_ID_TYPE ProcessIdType) ProcessId +/ {
        /+[case AD_PROCESS_ID_SYSTEM:]+/
            DWORD dwProcessId;
        /+[case AD_PROCESS_ID_GUID:]+/
            GUID guidProcessId;
        /+[default:]+/
            DWORD dwUnused; };;

// --------------------------------------------------------
// IDebugDefaultPort2

const GUID IID_IDebugDefaultPort2 = IDebugDefaultPort2.iid;

interface IDebugDefaultPort2 : IDebugPort2
{
    static const GUID iid = { 0x302f0f55,0x1ede,0x4777,[ 0x9b,0x38,0x11,0x5e,0x1f,0x22,0x9d,0x56 ] };
    HRESULT GetPortNotify(
        /+[out]+/ IDebugPortNotify2 *ppPortNotify);

    HRESULT GetServer(
        /+[out]+/ IDebugCoreServer3 *ppServer);

    HRESULT QueryIsLocal(
        );
};

// --------------------------------------------------------
// IDebugWindowsComputerPort2

const GUID IID_IDebugWindowsComputerPort2 = IDebugWindowsComputerPort2.iid;

interface IDebugWindowsComputerPort2 : IUnknown
{
    static const GUID iid = { 0x5fbb8ed3,0xecdb,0x412a,[ 0xbf,0xa3,0x3a,0x54,0xbe,0xb5,0xb2,0xd1 ] };

    HRESULT GetComputerInfo(
        /+[out]+/ COMPUTER_INFO * pInfo);
}
struct tagCOMPUTER_INFO
{
        // PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_IA64 (6), or PROCESSOR_ARCHITECTURE_AMD64 (9)
        WORD wProcessorArchitecture; 
        // See MSDN. Important value is VER_SUITE_TERMINAL
        WORD wSuiteMask;
        // { platform id -- 1 for 9x, 2 for NT, major version, minor version, service pack major }
        DWORD dwOperatingSystemVersion;
}
alias tagCOMPUTER_INFO COMPUTER_INFO;;

// --------------------------------------------------------
// IDebugPortRequest2
const GUID IID_IDebugPortRequest2 = IDebugPortRequest2.iid;

interface IDebugPortRequest2 : IUnknown
{
    static const GUID iid = { 0x8d36beb8,0x9bfe,0x47dd,[ 0xa1,0x1b,0x7b,0xa1,0xde,0x18,0xe4,0x49 ] };
    HRESULT GetPortName(
        /+[out]+/ BSTR* pbstrPortName);
};

// ------------------------------------------------------------------
// IDebugPortNotify2
const GUID IID_IDebugPortNotify2 = IDebugPortNotify2.iid;

interface IDebugPortNotify2 : IUnknown
{
    static const GUID iid = { 0xfb8d2032,0x2858,0x414c,[ 0x83,0xd9,0xf7,0x32,0x66,0x4e,0x0c,0x7a ] };
    HRESULT AddProgramNode(
        /+[in]+/ IDebugProgramNode2 pProgramNode);

    HRESULT RemoveProgramNode(
        /+[in]+/ IDebugProgramNode2 pProgramNode);
};

// ------------------------------------------------------------------
// IDebugPortEvents2
const GUID IID_IDebugPortEvents2 = IDebugPortEvents2.iid;

interface IDebugPortEvents2 : IUnknown
{
    static const GUID iid = { 0x564fa275,0x12e1,0x4b5f,[ 0x83,0x16,0x4d,0x79,0xbc,0xef,0x72,0x46 ] };
    HRESULT Event(
        /+[in]+/ IDebugCoreServer2 pServer,
        /+[in]+/ IDebugPort2 pPort,
        /+[in]+/ IDebugProcess2 pProcess,
        /+[in]+/ IDebugProgram2 pProgram,
        /+[in]+/ IDebugEvent2 pEvent,
        in IID* riidEvent);
};

// ------------------------------------------------------------------
// IDebugMDMUtil2_V7
const GUID IID_IDebugMDMUtil2_V7 = IDebugMDMUtil2_V7.iid;

interface IDebugMDMUtil2_V7 : IUnknown
{
    static const GUID iid = { 0xf3062547,0x43d8,0x4dc2,[ 0xb1,0x8e,0xe1,0x46,0x0f,0xf2,0xc4,0x22 ] };
    // For the following methods guidEngine specifies the debug engine the
    // call applies to. Use GUID_NULL to specify all engines.

    // Add or remove a process that the VM should NOT ever debug
    // (i.e. DON'T use the debugger interpreter loop for a specified process).
    HRESULT AddPIDToIgnore(
        in GUID* guidEngine,
        in DWORD dwPid);
    HRESULT RemovePIDToIgnore(
        in GUID* guidEngine,
        in DWORD dwPid);

    // Add or remove a process that the VM should debug
    // (i.e. DO use the debugger interpreter loop for a specified process).
    HRESULT AddPIDToDebug(
        in GUID* guidEngine,
        in DWORD dwPid);
    HRESULT RemovePIDToDebug(
        in GUID* guidEngine,
        in DWORD dwPid);

    alias DWORD DYNDEBUGFLAGS;
    enum /+ enum_DYNDEBUGFLAGS+/ : int 
{
        DYNDEBUG_ATTACH       = 1,
        DYNDEBUG_JIT       = 2,
        DYNDEBUG_REMOTEJIT = 4
}
alias int enum_DYNDEBUGFLAGS;

    // Access to dynamic debugging flags (JIT, attach, ...).
    // Settings are  on a per Engine basis for the entire machine.
    // Users of these two APIs should always call GetDynamicDebuggingFlags,
    //   set or clear specific bits, then call SetDynamicDebuggingFlags
    HRESULT SetDynamicDebuggingFlags(
        in GUID* guidEngine,
        in DYNDEBUGFLAGS dwFlags);
    HRESULT GetDynamicDebuggingFlags(
        in GUID* guidEngine,
        /+[out]+/ DYNDEBUGFLAGS *pdwFlags);

    // Set the clsid as the default JIT Server
    HRESULT SetDefaultJITServer(
        in CLSID* clsidJITServer);
    // Retrieve the default JIT Server (CLSID_NULL if there isn't one)
    HRESULT GetDefaultJITServer(
        /+[out]+/ CLSID *pClsidJITServer);
    // Register debug engines for a JIT debugger.
    // arrRemoteFlags may be NULL if remote JIT is not supported for any engine.
    // arrguidEngines and arrRemoteFlags are ignored if fRegister is FALSE.
    HRESULT RegisterJITDebugEngines(
        in CLSID* clsidJITServer,
        /+[size_is (celtEngs)]+/ in GUID *arrguidEngines,
        /+[ptr ,size_is(celtEngs)]+/ in BOOL *arrRemoteFlags,
        in DWORD celtEngs,
        in BOOL fRegister);

    enum DWORD S_UNKNOWN = 0x3;

    // Should the VM use the debugger loop for this pid?
    HRESULT CanDebugPID(
        in GUID* guidEngine,
        in DWORD pid);
}

const GUID IID_IDebugMDMUtil3_V7 = IDebugMDMUtil3_V7.iid;

interface IDebugMDMUtil3_V7 : IDebugMDMUtil2_V7
{
    static const GUID iid = { 0xaf598dea,0xce92,0x443b,[ 0xa0,0xb5,0x99,0x92,0xff,0x66,0x0b,0xc4 ] };

    HRESULT DiagnoseScriptDebuggingError(
        in DWORD dwDebuggeeProcessId);

    HRESULT DiagnoseWebDebuggingError(
        in WEB_DEBUG_TYPE dwWebType,
        /+[ ptr]+/ in LPCWSTR pszUrl);

    HRESULT DiagnoseASPDebugging(
        /+[ ptr]+/ in LPCWSTR szASPUserAccount
        );
}
enum
    {
        WEB_DEBUG_ASP_NET                = 0x0001,
    };
alias DWORD WEB_DEBUG_TYPE;;

// ------------------------------------------------------------------
// IDebugSession2
const GUID IID_IDebugSession2 = IDebugSession2.iid;

// avoid using enc
interface IDebugENCUpdate : IUnknown {
}

interface IDebugSession2 : IUnknown
{
    static const GUID iid = { 0x8948300f,0x8bd5,0x4728,[ 0xa1,0xd8,0x83,0xd1,0x72,0x29,0x5a,0x9d ] };

    HRESULT GetName(
        /+[out]+/ BSTR* pbstrName);

    HRESULT SetName(
        in LPCOLESTR pszName);

    HRESULT EnumProcesses(
        /+[out]+/ IEnumDebugProcesses2 * ppEnum);

    HRESULT Launch(
        /+[ ptr]+/ in LPCOLESTR pszMachine,
        /+[in]+/ IDebugPort2 pPort,
        /+[ ptr]+/ in LPCOLESTR pszExe,
        /+[ ptr]+/ in LPCOLESTR pszArgs,
        /+[ ptr]+/ in LPCOLESTR pszDir,
        /+[ ptr]+/ in BSTR bstrEnv,
        /+[ ptr]+/ in LPCOLESTR pszOptions,
        in LAUNCH_FLAGS dwLaunchFlags,
        in DWORD hStdInput,
        in DWORD hStdOutput,
        in DWORD hStdError,
        in GUID* guidLaunchingEngine,
        /+[in]+/ IDebugEventCallback2 pCallback,
        /+[ size_is (celtSpecificEngines)]+/ in GUID* rgguidSpecificEngines,
        in DWORD celtSpecificEngines,
        /+[out]+/ IDebugProcess2 * ppProcess);

    HRESULT RegisterJITServer(
        in CLSID* clsidJITServer);

    HRESULT Terminate(
        in BOOL fForce);

    HRESULT Detach();

    HRESULT CauseBreak();

    HRESULT CreatePendingBreakpoint(
        /+[in]+/ IDebugBreakpointRequest2 pBPRequest,
        /+[out]+/ IDebugPendingBreakpoint2 * ppPendingBP);

    HRESULT EnumPendingBreakpoints(
        /+[in]+/ IDebugProgram2 pProgram,
        /+[ ptr]+/ in LPCOLESTR pszProgram,
        /+[out]+/ IEnumDebugPendingBreakpoints2 * ppEnumBPs);

    HRESULT EnumMachines__deprecated(
        /+[out]+/ IEnumDebugMachines2__deprecated * ppEnum);

    HRESULT ConnectToServer(
        /+[ ptr]+/ in LPCOLESTR szServerName,
        /+[out]+/ IDebugCoreServer2 * ppServer);

    HRESULT DisconnectServer(
        /+[in]+/ IDebugCoreServer2 pServer);

    HRESULT ShutdownSession();

    HRESULT EnumCodeContexts(
        /+[in]+/ IDebugProgram2 pProgram,
        /+[in]+/ IDebugDocumentPosition2 pDocPos,
        /+[out]+/ IEnumDebugCodeContexts2 *ppEnum);

    HRESULT SetException(
        in EXCEPTION_INFO* pException);

    HRESULT EnumSetExceptions(
        /+[in]+/ IDebugProgram2 pProgram,
        /+[ ptr]+/ in LPCOLESTR pszProgram,
        // Either guidLang or guidEng
        in GUID* guidType,
        /+[out]+/ IEnumDebugExceptionInfo2 * ppEnum);

    HRESULT RemoveSetException(
        in EXCEPTION_INFO* pException);

    HRESULT RemoveAllSetExceptions(
        // Either guidLang or guidEng
        in GUID* guidType);

    // The top-level default exceptions are pseudo-exceptions that describe the
    // default exception handling behavior for a given language or runtime architecture.
    // Example: "C++": EXCEPTION_STOP_SECOND_CHANCE
    // EXCEPTION_STOP_FIRST_CHANCE_USE_PARENT and EXCEPTION_STOP_SECOND_CHANCE_USE_PARENT
    // are invalid for these top-level pseudo-exceptions.
    HRESULT EnumDefaultExceptions(
        /+[ ptr]+/ in EXCEPTION_INFO* pParentException,
        /+[out]+/ IEnumDebugExceptionInfo2 * ppEnum);

    HRESULT GetENCUpdate(
        /+[in]+/ IDebugProgram2 pProgram,
        /+[out]+/ IDebugENCUpdate** ppUpdate);

    HRESULT SetLocale(
        in WORD wLangID);

    HRESULT SetRegistryRoot(
        /+[ ptr]+/ in LPCOLESTR pszRegistryRoot);

    HRESULT IsAlive();

    HRESULT ClearAllSessionThreadStackFrames();

    HRESULT __deprecated_GetSessionId(
        /+[in]+/ IDebugEventCallback2 pCallback,
        /+[ size_is (celtSpecificEngines), ptr]+/ in GUID* rgguidSpecificEngines,
        in DWORD celtSpecificEngines,
        /+[ ptr]+/ in LPCOLESTR pszStartPageUrl,
        /+[out]+/ BSTR* pbstrSessionId);

    HRESULT SetEngineMetric(
        in GUID* guidEngine,
        in LPCOLESTR pszMetric,
        in VARIANT varValue);

    HRESULT SetStoppingModel(
        in STOPPING_MODEL dwStoppingModel);

    HRESULT GetStoppingModel(
        /+[out]+/ STOPPING_MODEL* pdwStoppingModel);

    HRESULT __deprecated_RegisterSessionWithServer(
        in LPCOLESTR pwszServerName);
}
enum /+ enum_LAUNCH_FLAGS+/ : DWORD 
{
        // Launch the process for debugging
        LAUNCH_DEBUG            = 0x0000,
        // Launch the process without debugging it
        LAUNCH_NODEBUG            = 0x0001,
        // Launch the process with EnC enabled.
        LAUNCH_ENABLE_ENC       = 0x0002,
        // Launch the process and merge the environment
        LAUNCH_MERGE_ENV        = 0x0004
}
alias DWORD enum_LAUNCH_FLAGS;
alias DWORD LAUNCH_FLAGS;
enum /+ enum_EXCEPTION_STATE+/ : DWORD 
{
        EXCEPTION_NONE                                = 0x0000,
        EXCEPTION_STOP_FIRST_CHANCE                    = 0x0001,
        EXCEPTION_STOP_SECOND_CHANCE                = 0x0002,
        EXCEPTION_STOP_USER_FIRST_CHANCE            = 0x0010,
        EXCEPTION_STOP_USER_UNCAUGHT                = 0x0020,

        // These are no longer used:
        EXCEPTION_STOP_FIRST_CHANCE_USE_PARENT        = 0x0004,
        EXCEPTION_STOP_SECOND_CHANCE_USE_PARENT        = 0x0008,
        EXCEPTION_STOP_USER_FIRST_CHANCE_USE_PARENT = 0x0040,
        EXCEPTION_STOP_USER_UNCAUGHT_USE_PARENT     = 0x0080,

        EXCEPTION_STOP_ALL                          = 0x00FF,

        EXCEPTION_CANNOT_BE_CONTINUED                = 0x0100,

        // the following flags are for exception types only
        EXCEPTION_CODE_SUPPORTED                    = 0x1000,
        EXCEPTION_CODE_DISPLAY_IN_HEX               = 0x2000,
        EXCEPTION_JUST_MY_CODE_SUPPORTED            = 0x4000,
        EXCEPTION_MANAGED_DEBUG_ASSISTANT           = 0x8000,
}
alias DWORD enum_EXCEPTION_STATE;
alias DWORD EXCEPTION_STATE;
struct tagEXCEPTION_INFO
{
        IDebugProgram2 pProgram;
        BSTR bstrProgramName;
        BSTR bstrExceptionName;
        DWORD dwCode;
        EXCEPTION_STATE dwState;
        // Either guidLang or guidEng
        GUID guidType;
}
alias tagEXCEPTION_INFO EXCEPTION_INFO;
enum /+ enum_STOPPING_MODEL+/ : DWORD 
{
        STOPPING_MODEL_STOP_ALL    = 0x0001,
        STOPPING_MODEL_STOP_ONE    = 0x0002,
}
alias DWORD enum_STOPPING_MODEL;
alias DWORD STOPPING_MODEL;;

// Support for JustMyCode
struct _JMC_CODE_SPEC
{
    BOOL fIsUserCode;           // TRUE implies "user" code
    BSTR bstrModuleName;
}
alias _JMC_CODE_SPEC JMC_CODE_SPEC;
    
// ------------------------------------------------------------------
// IDebugSession3
const GUID IID_IDebugSession3 = IDebugSession3.iid;

interface IDebugSession3 : IDebugSession2
{
    static const GUID iid = { 0xBBF74DB9,0x39D5,0x406e,[ 0x8B,0xC3,0x3B,0xA9,0xDD,0x34,0xC0,0x2E ] };

    // szSymbolSearchPath uses the unicode delimiting character to seperate
    // search paths.
    HRESULT SetSymbolPath(
        /+[ ptr]+/ in LPCOLESTR szSymbolSearchPath,
        /+[ ptr]+/ in LPCOLESTR szSymbolCachePath,
        in LOAD_SYMBOLS_FLAGS Flags);

    // Load symbols for all modules that do not have them Returns S_OK if at
    // least one module loaded symbols returns S_FALSE if no modules loaded symbols.
    HRESULT LoadSymbols();

    HRESULT RegisterCallback(
        /+[in]+/ IDebugEventCallback2 pCallback);

    HRESULT ConnectToServerEx(
        /+[ ptr]+/ in LPCOLESTR szServerName,
        in CONNECT_REASON ConnectReason,
        /+[out]+/ IDebugCoreServer3 * ppServer);

    // Pass on the JustMyCode info to the engines
    HRESULT SetJustMyCodeState(
        in BOOL fUpdate,                                  // TRUE = update; FALSE = reset (ignore everything sent earlier)
        in DWORD dwModules,                               // count
        /+[ size_is (dwModules), ptr]+/ in JMC_CODE_SPEC* rgJMCSpec); // array of info about modules

    // Get the most recently used server names
    HRESULT GetRecentServerNames(
        /+[out]+/ BSTR_ARRAY *pServers);

    // Set how many server names should be remembered
    HRESULT SetMaxRecentServerNames(
        in DWORD dwNewMax);

    HRESULT InitializeFeatures(
        in SESSION_FEATURES EnabledFeatures
        );

    HRESULT SetAllExceptions(
        in EXCEPTION_STATE dwState
        );

    // return E_FAIL if we are breaking on specific exceptions
    HRESULT GetStateForAllExceptions(
        /+[out]+/ EXCEPTION_STATE *pdwState
        );

    HRESULT AddExceptionCallback(
        in EXCEPTION_INFO* pException,
        /+[in]+/ IDebugExceptionCallback2 pCallback
        );

    HRESULT RemoveExceptionCallback(
        in EXCEPTION_INFO* pException,
        /+[in]+/ IDebugExceptionCallback2 pCallback
        );

    HRESULT BlockingShutdownSession(
        in DWORD dwTimeout
        );
}
enum
{
        CONNECT_LOCAL,
        CONNECT_ATTACH,
        CONNECT_LAUNCH,
        CONNECT_WEB_AUTO_ATTACH,
        CONNECT_SQL_AUTO_ATTACH,
        CONNECT_CAUSALITY,
        CONNECT_DIAGNOSE_WEB_ERROR
}
alias int CONNECT_REASON;
enum /+ enum_SESSION_FEATURES+/ : DWORD 
{
        FEATURE_REMOTE_DEBUGGING = 0x1,
        FEATURE_CAUSALITY = 0x2
}
alias DWORD enum_SESSION_FEATURES;
alias DWORD SESSION_FEATURES;
alias DWORD LOAD_SYMBOLS_FLAGS;;

// ------------------------------------------------------------------
// IDebugEngine2
const GUID IID_IDebugEngine2 = IDebugEngine2.iid;

interface IDebugEngine2 : IUnknown
{
    static const GUID iid = { 0xba105b52,0x12f1,0x4038,[ 0xae,0x64,0xd9,0x57,0x85,0x87,0x4c,0x47 ] };

    HRESULT EnumPrograms(
        /+[out]+/ IEnumDebugPrograms2 * ppEnum);

    HRESULT Attach(
        /+[ size_is (celtPrograms), length_is(celtPrograms)]+/ /+[in]+/ IDebugProgram2 * rgpPrograms,
        /+[ size_is (celtPrograms), length_is(celtPrograms)]+/ /+[in]+/ IDebugProgramNode2 * rgpProgramNodes,
        in DWORD celtPrograms,
        /+[in]+/ IDebugEventCallback2 pCallback,
        in ATTACH_REASON dwReason);

    HRESULT CreatePendingBreakpoint(
        /+[in]+/ IDebugBreakpointRequest2 pBPRequest,
        /+[out]+/ IDebugPendingBreakpoint2 * ppPendingBP);

    HRESULT SetException(
        in EXCEPTION_INFO* pException);

    HRESULT RemoveSetException(
        in EXCEPTION_INFO* pException);

    HRESULT RemoveAllSetExceptions(
        // Either guidlang or guidEng
        in GUID* guidType);

    HRESULT GetEngineId(
        /+[out]+/ GUID *pguidEngine);

    HRESULT DestroyProgram(
        /+[in]+/ IDebugProgram2 pProgram);

    HRESULT ContinueFromSynchronousEvent(
        /+[in]+/ IDebugEvent2 pEvent);

    HRESULT SetLocale(
        in WORD wLangID);

    HRESULT SetRegistryRoot(
        /+[ ptr]+/ in LPCOLESTR pszRegistryRoot);

    HRESULT SetMetric(
        in LPCOLESTR pszMetric,
        in VARIANT varValue);

    // These methods were added after the Office fork
    HRESULT CauseBreak();
}
enum /+ enum_ATTACH_REASON+/ : DWORD 
{
        // Attaching because we launched the process
        // (prog create and thread create can be stopping events; send entry point, not attach complete)
        ATTACH_REASON_LAUNCH    = 0x0001,
        // Attaching because the user requested an attach
        // (prog create and thread create cannot be stopping events; send attach complete)
        ATTACH_REASON_USER        = 0x0002,
        // Attaching because we're already debugging the process
        // (prog create and thread create can be stopping events; send attach complete)
        ATTACH_REASON_AUTO        = 0x0003,
}
alias DWORD enum_ATTACH_REASON;
alias DWORD ATTACH_REASON;;

// ------------------------------------------------------------------
// IDebugEngineLaunch2
const GUID IID_IDebugEngineLaunch2 = IDebugEngineLaunch2.iid;

interface IDebugEngineLaunch2 : IUnknown
{
    static const GUID iid = { 0xc7c1462f,0x9736,0x466c,[ 0xb2,0xc1,0xb6,0xb2,0xde,0xdb,0xf4,0xa7 ] };
    HRESULT LaunchSuspended(
        /+[ ptr]+/ in LPCOLESTR pszServer,
        /+[in]+/ IDebugPort2 pPort,
        /+[ ptr]+/ in LPCOLESTR pszExe,
        /+[ ptr]+/ in LPCOLESTR pszArgs,
        /+[ ptr]+/ in LPCOLESTR pszDir,
        /+[ ptr]+/ in BSTR bstrEnv,
        /+[ ptr]+/ in LPCOLESTR pszOptions,
        in LAUNCH_FLAGS dwLaunchFlags,
        in DWORD hStdInput,
        in DWORD hStdOutput,
        in DWORD hStdError,
        /+[in]+/ IDebugEventCallback2 pCallback,
        /+[out]+/ IDebugProcess2 *ppProcess);

    HRESULT ResumeProcess(
    /+[in]+/ IDebugProcess2 pProcess);

    HRESULT CanTerminateProcess(
        /+[in]+/ IDebugProcess2 pProcess);

    HRESULT TerminateProcess(
        /+[in]+/ IDebugProcess2 pProcess);
};

// ------------------------------------------------------------------
// IDebugEngine3
const GUID IID_IDebugEngine3 = IDebugEngine3.iid;

interface IDebugEngine3 : IDebugEngine2
{
    static const GUID iid = { 0xA60384F6,0x3712,0x4cb3,[ 0xBC,0x46,0x81,0xE6,0x40,0x2F,0xEE,0x99 ] };
    // szSymbolSearchPath uses the unicode delimiting character to seperate
    // search paths.
    HRESULT SetSymbolPath(
        in LPCOLESTR szSymbolSearchPath,
        in LPCOLESTR szSymbolCachePath,
        in LOAD_SYMBOLS_FLAGS Flags);

    // Load symbols for all modules that do not have any Returns S_OK if at
    // least one module loaded symbols returns S_FALSE if no modules loaded symbols.
    HRESULT LoadSymbols();

    // Pass on the JustMyCode info to the engines
    HRESULT SetJustMyCodeState(
        in BOOL fUpdate,                                      // TRUE = update; FALSE = reset (ignore everything sent earlier)
        in DWORD dwModules,                                   // count
        /+[ size_is (dwModules), ptr]+/ in JMC_CODE_SPEC* rgJMCSpec); // array of info about modules

    // Pass the guid of the engine from the METRICs.
    HRESULT SetEngineGuid(
        in GUID *guidEngine);

    HRESULT SetAllExceptions(
        in EXCEPTION_STATE dwState);
}

// ------------------------------------------------------------------
// IDebugEventCallback2
const GUID IID_IDebugEventCallback2 = IDebugEventCallback2.iid;

interface IDebugEventCallback2 : IUnknown
{
    static const GUID iid = { 0xade2eeb9,0xfc85,0x4f5b,[ 0xb5,0xd9,0xd4,0x31,0xb4,0xaa,0xc3,0x1a ] };

    HRESULT Event(
        /+[in]+/ IDebugEngine2 pEngine,
        /+[in]+/ IDebugProcess2 pProcess,
        /+[in]+/ IDebugProgram2 pProgram,
        /+[in]+/ IDebugThread2 pThread,
        /+[in]+/ IDebugEvent2 pEvent,
        in IID* riidEvent,
        in DWORD dwAttrib);
}
enum /+ enum_EVENTATTRIBUTES+/ : DWORD 
{
        // The event is asynchronous; no reply is necessary
        EVENT_ASYNCHRONOUS    = 0x0000,
        // The event is synchronous; reply via IDebugEngine2::ContinueFromSynchronousEvent
        EVENT_SYNCHRONOUS    = 0x0001,
        // The event is stopping; reply via IDebugThread2::ContinueFromStoppingEvent
        EVENT_STOPPING        = 0x0002,
        EVENT_ASYNC_STOP    = 0x0002,        // (not currently supported)
        EVENT_SYNC_STOP        = 0x0003,
        // The event is sent immediately and synchronously to the IDE
        // (even if the IDE is currently handling an event)
        EVENT_IMMEDIATE        = 0x0004,
        // The event is for expression evaluation
        EVENT_EXPRESSION_EVALUATION = 0x0008
}
alias DWORD enum_EVENTATTRIBUTES;
alias DWORD EVENTATTRIBUTES;;

// ------------------------------------------------------------------
// IDebugSettingsCallback2

const GUID IID_IDebugSettingsCallback2 = IDebugSettingsCallback2.iid;

interface IDebugSettingsCallback2 : IUnknown
{
    static const GUID iid = { 0x050b1813,0x91db,0x47a0,[ 0x89,0x87,0xfc,0x55,0xbd,0xd6,0x36,0x2b ] };
    HRESULT GetMetricGuid(
        in LPCWSTR pszType,
        in GUID* guidSection,
        in LPCWSTR pszMetric,
        /+[out]+/ GUID* pguidValue
        );

    HRESULT GetMetricDword(
        in LPCWSTR pszType,
        in GUID* guidSection,
        in LPCWSTR pszMetric,
        /+[out]+/ DWORD* pdwValue
        );

    HRESULT GetEEMetricString(
        in GUID* guidLang,
        in GUID* guidVendor,
        in LPCWSTR pszMetric,
        /+[out]+/ BSTR* pbstrValue
        );

    HRESULT GetEEMetricGuid(
        in GUID* guidLang,
        in GUID* guidVendor,
        in LPCWSTR pszMetric,
        /+[out]+/ GUID* pguidValue
        );

    HRESULT GetEEMetricFile(
        in GUID* guidLang,
        in GUID* guidVendor,
        in LPCWSTR pszMetric,
        /+[out]+/ BSTR* pbstrValue
        );
        
    HRESULT EnumEEs(
        in DWORD celtBuffer,
        /+[in, out, ptr, size_is(celtBuffer), length_is(*pceltEEs)]+/ GUID* rgguidLang,
        /+[in, out, ptr, size_is(celtBuffer), length_is(*pceltEEs)]+/ GUID* rgguidVendor,
        /+[in, out]+/ DWORD* pceltEEs
        );

    HRESULT GetEEMetricDword(
        in GUID* guidLang,
        in GUID* guidVendor,
        in LPCWSTR pszMetric,
        /+[out]+/ DWORD* pdwValue
        );

    HRESULT GetEELocalObject(
        in GUID* guidLang,
        in GUID* guidVendor,
        in LPCWSTR pszMetric,
        /+[out]+/ IUnknown * ppUnk
    );

    HRESULT GetMetricString(
        in LPCWSTR pszType,
        in GUID* guidSection,
        in LPCWSTR pszMetric,
        /+[out]+/ BSTR* pbstrValue
        );
};

// ------------------------------------------------------------------
// IDebugEvent2
const GUID IID_IDebugEvent2 = IDebugEvent2.iid;

interface IDebugEvent2 : IUnknown
{
    static const GUID iid = { 0x423238d6,0xda42,0x4989,[ 0x96,0xfb,0x6b,0xba,0x26,0xe7,0x2e,0x09 ] };
    HRESULT GetAttributes(
        /+[out]+/ DWORD* pdwAttrib);
};

// ------------------------------------------------------------------
// IDebugSessionCreateEvent2
const GUID IID_IDebugSessionCreateEvent2 = IDebugSessionCreateEvent2.iid;

interface IDebugSessionCreateEvent2 : IUnknown
{
    static const GUID iid = { 0x2c2b15b7,0xfc6d,0x45b3,[ 0x96,0x22,0x29,0x66,0x5d,0x96,0x4a,0x76 ] };
};

// ------------------------------------------------------------------
// IDebugSessionDestroyEvent2
const GUID IID_IDebugSessionDestroyEvent2 = IDebugSessionDestroyEvent2.iid;

interface IDebugSessionDestroyEvent2 : IUnknown
{
    static const GUID iid = { 0xf199b2c2,0x88fe,0x4c5d,[ 0xa0,0xfd,0xaa,0x04,0x6b,0x0d,0xc0,0xdc ] };
};

// ------------------------------------------------------------------
// IDebugEngineCreateEvent2
const GUID IID_IDebugEngineCreateEvent2 = IDebugEngineCreateEvent2.iid;

interface IDebugEngineCreateEvent2 : IUnknown
{
    static const GUID iid = { 0xfe5b734c,0x759d,0x4e59,[ 0xab,0x04,0xf1,0x03,0x34,0x3b,0xdd,0x06 ] };
    HRESULT GetEngine(
        /+[out]+/ IDebugEngine2 *pEngine);
};

// ------------------------------------------------------------------
// IDebugProcessCreateEvent2
const GUID IID_IDebugProcessCreateEvent2 = IDebugProcessCreateEvent2.iid;

interface IDebugProcessCreateEvent2 : IUnknown
{
    static const GUID iid = { 0xbac3780f,0x04da,0x4726,[ 0x90,0x1c,0xba,0x6a,0x46,0x33,0xe1,0xca ] };
};

// ------------------------------------------------------------------
// IDebugProcessDestroyEvent2
const GUID IID_IDebugProcessDestroyEvent2 = IDebugProcessDestroyEvent2.iid;

interface IDebugProcessDestroyEvent2 : IUnknown
{
    static const GUID iid = { 0x3e2a0832,0x17e1,0x4886,[ 0x8c,0x0e,0x20,0x4d,0xa2,0x42,0x99,0x5f ] };
};

// ------------------------------------------------------------------
// IDebugProgramCreateEvent2
const GUID IID_IDebugProgramCreateEvent2 = IDebugProgramCreateEvent2.iid;

interface IDebugProgramCreateEvent2 : IUnknown
{
    static const GUID iid = { 0x96cd11ee,0xecd4,0x4e89,[ 0x95,0x7e,0xb5,0xd4,0x96,0xfc,0x41,0x39 ] };
};

// ------------------------------------------------------------------
// IDebugProgramDestroyEvent2
const GUID IID_IDebugProgramDestroyEvent2 = IDebugProgramDestroyEvent2.iid;

interface IDebugProgramDestroyEvent2 : IUnknown
{
    static const GUID iid = { 0xe147e9e3,0x6440,0x4073,[ 0xa7,0xb7,0xa6,0x55,0x92,0xc7,0x14,0xb5 ] };
    HRESULT GetExitCode(
        /+[out]+/ DWORD* pdwExit);
};

// ------------------------------------------------------------------
// IDebugProgramDestroyEventFlags2
const GUID IID_IDebugProgramDestroyEventFlags2 = IDebugProgramDestroyEventFlags2.iid;

interface IDebugProgramDestroyEventFlags2 : IUnknown
{
    static const GUID iid = { 0x7e072bee,0x24e7,0x43eb,[ 0x9b,0xce,0x06,0x40,0x2c,0x70,0xe0,0x18 ] };

    HRESULT GetFlags(
        /+[out]+/ PROGRAM_DESTROY_FLAGS* pdwFlags);
}
enum /+ enum_PROGRAM_DESTROY_FLAGS+/ : DWORD 
{
        // continue debugging even if no programs are left
        PROGRAM_DESTROY_CONTINUE_DEBUGGING = 0x1
}
alias DWORD enum_PROGRAM_DESTROY_FLAGS;
alias DWORD PROGRAM_DESTROY_FLAGS;

// ------------------------------------------------------------------
// IDebugThreadCreateEvent2
const GUID IID_IDebugThreadCreateEvent2 = IDebugThreadCreateEvent2.iid;

interface IDebugThreadCreateEvent2 : IUnknown
{
    static const GUID iid = { 0x2090ccfc,0x70c5,0x491d,[ 0xa5,0xe8,0xba,0xd2,0xdd,0x9e,0xe3,0xea ] };
};

// ------------------------------------------------------------------
// IDebugThreadDestroyEvent2
const GUID IID_IDebugThreadDestroyEvent2 = IDebugThreadDestroyEvent2.iid;

interface IDebugThreadDestroyEvent2 : IUnknown
{
    static const GUID iid = { 0x2c3b7532,0xa36f,0x4a6e,[ 0x90,0x72,0x49,0xbe,0x64,0x9b,0x85,0x41 ] };
    HRESULT GetExitCode(
        /+[out]+/ DWORD* pdwExit);
};

// ------------------------------------------------------------------
// IDebugLoadCompleteEvent2
const GUID IID_IDebugLoadCompleteEvent2 = IDebugLoadCompleteEvent2.iid;

interface IDebugLoadCompleteEvent2 : IUnknown
{
    static const GUID iid = { 0xb1844850,0x1349,0x45d4,[ 0x9f,0x12,0x49,0x52,0x12,0xf5,0xeb,0x0b ] };
};

// ------------------------------------------------------------------
// IDebugEntryPointEvent2
const GUID IID_IDebugEntryPointEvent2 = IDebugEntryPointEvent2.iid;

interface IDebugEntryPointEvent2 : IUnknown
{
    static const GUID iid = { 0xe8414a3e,0x1642,0x48ec,[ 0x82,0x9e,0x5f,0x40,0x40,0xe1,0x6d,0xa9 ] };
};

// ------------------------------------------------------------------
// IDebugStepCompleteEvent2
const GUID IID_IDebugStepCompleteEvent2 = IDebugStepCompleteEvent2.iid;

interface IDebugStepCompleteEvent2 : IUnknown
{
    static const GUID iid = { 0x0f7f24c1,0x74d9,0x4ea6,[ 0xa3,0xea,0x7e,0xdb,0x2d,0x81,0x44,0x1d ] };
};

// ------------------------------------------------------------------
// IDebugCanStopEvent2
const GUID IID_IDebugCanStopEvent2 = IDebugCanStopEvent2.iid;

interface IDebugCanStopEvent2 : IUnknown
{
    static const GUID iid = { 0xb5b0d747,0xd4d2,0x4e2d,[ 0x87,0x2d,0x74,0xda,0x22,0x03,0x78,0x26 ] };

    HRESULT GetReason(
        /+[out]+/ CANSTOP_REASON *pcr);

    HRESULT CanStop(
        in BOOL fCanStop);

    HRESULT GetDocumentContext(
        /+[out]+/ IDebugDocumentContext2 *ppDocCxt);

    HRESULT GetCodeContext(
        /+[out]+/ IDebugCodeContext2 * ppCodeContext);
}
enum /+ enum_CANSTOP_REASON+/ : DWORD 
{
        CANSTOP_ENTRYPOINT  = 0x0000,
        CANSTOP_STEPIN      = 0x0001
}
alias DWORD enum_CANSTOP_REASON;
alias DWORD CANSTOP_REASON;;

// ------------------------------------------------------------------
// IDebugBreakEvent2
const GUID IID_IDebugBreakEvent2 = IDebugBreakEvent2.iid;

interface IDebugBreakEvent2 : IUnknown
{
    static const GUID iid = { 0xc7405d1d,0xe24b,0x44e0,[ 0xb7,0x07,0xd8,0xa5,0xa4,0xe1,0x64,0x1b ] };
};

// ------------------------------------------------------------------
// IDebugBreakpointEvent2
const GUID IID_IDebugBreakpointEvent2 = IDebugBreakpointEvent2.iid;

interface IDebugBreakpointEvent2 : IUnknown
{
    static const GUID iid = { 0x501c1e21,0xc557,0x48b8,[ 0xba,0x30,0xa1,0xea,0xb0,0xbc,0x4a,0x74 ] };
    HRESULT EnumBreakpoints(
        /+[out]+/ IEnumDebugBoundBreakpoints2 * ppEnum);
};

// ------------------------------------------------------------------
// IDebugExceptionEvent2
const GUID IID_IDebugExceptionEvent2 = IDebugExceptionEvent2.iid;

interface IDebugExceptionEvent2 : IUnknown
{
    static const GUID iid = { 0x51a94113,0x8788,0x4a54,[ 0xae,0x15,0x08,0xb7,0x4f,0xf9,0x22,0xd0 ] };
    HRESULT GetException(
        /+[out]+/ EXCEPTION_INFO* pExceptionInfo);

    HRESULT GetExceptionDescription(
        /+[out]+/ BSTR* pbstrDescription);

    HRESULT CanPassToDebuggee();

    HRESULT PassToDebuggee(
        in BOOL fPass);
};

// based on EXCEPTION_RECORD only Win32/64-agnostic
struct _NATIVE_EXCEPTION_INFO
{
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD NumberOfParameters;
    UINT64[15] ExceptionInformation;
}
alias _NATIVE_EXCEPTION_INFO NATIVE_EXCEPTION_INFO;

// ------------------------------------------------------------------
// IDebugNativeExceptionInfo
//
// Not an event as such, but QI-able from an IDebugExceptionEvent2
// to get more information
const GUID IID_IDebugNativeExceptionInfo = IDebugNativeExceptionInfo.iid;

interface IDebugNativeExceptionInfo : IUnknown
{
    static const GUID iid = { 0x3d320710,0x06c0,0x437b,[ 0xa5,0x5f,0x82,0x6f,0x48,0xcc,0x7e,0xe7 ] };
    HRESULT GetNativeException(
        /+[out]+/ NATIVE_EXCEPTION_INFO* pExceptionInfo);
};

// ------------------------------------------------------------------
// IDebugManagedExceptionInfo2
//
// Not an event as such, but QI-able from an IDebugExceptionEvent2
// to get more information
const GUID IID_IDebugManagedExceptionInfo2 = IDebugManagedExceptionInfo2.iid;

interface IDebugManagedExceptionInfo2 : IUnknown
{
    static const GUID iid = { 0xd288564a,0xedb2,0x4214,[ 0x86,0x90,0xff,0x9a,0x82,0x87,0x03,0x79 ] };

    HRESULT GetExceptionMessage(
        /+[out]+/ BSTR* pbstrExceptionMessage);

    HRESULT GetExceptionBoundaryType(
        /+[out]+/ EXCEPTION_BOUNDARY_TYPE *pType);
}
enum /+ tagEXCEPTION_BOUNDARY_TYPE+/ : int 
{ 
        EXCEPTION_BOUNDARY_NONE, 
        EXCEPTION_BOUNDARY_APPDOMAIN, 
        EXCEPTION_BOUNDARY_UNMANAGED,
}
alias int tagEXCEPTION_BOUNDARY_TYPE;
alias  tagEXCEPTION_BOUNDARY_TYPE EXCEPTION_BOUNDARY_TYPE;;

// ------------------------------------------------------------------
// IDebugOutputStringEvent2
const GUID IID_IDebugOutputStringEvent2 = IDebugOutputStringEvent2.iid;

interface IDebugOutputStringEvent2 : IUnknown
{
    static const GUID iid = { 0x569c4bb1,0x7b82,0x46fc,[ 0xae,0x28,0x45,0x36,0xdd,0xad,0x75,0x3e ] };
    HRESULT GetString(
        /+[out]+/ BSTR* pbstrString);
};

// ------------------------------------------------------------------
// IDebugModuleLoadEvent2
const GUID IID_IDebugModuleLoadEvent2 = IDebugModuleLoadEvent2.iid;

interface IDebugModuleLoadEvent2 : IUnknown
{
    static const GUID iid = { 0x989db083,0x0d7c,0x40d1,[ 0xa9,0xd9,0x92,0x1b,0xf6,0x11,0xa4,0xb2 ] };
    HRESULT GetModule(
        /+[out]+/ IDebugModule2 * pModule,
        // Optional message that describes the event
        /+[in, out]+/ BSTR* pbstrDebugMessage,
        // Set to TRUE if the module's loading; FALSE if unloading
        /+[in, out]+/ BOOL* pbLoad);
};

// ------------------------------------------------------------------
// IDebugSymbolSearchEvent2
const GUID IID_IDebugSymbolSearchEvent2 = IDebugSymbolSearchEvent2.iid;

interface IDebugSymbolSearchEvent2 : IUnknown
{
    static const GUID iid = { 0x638F7C54,0xC160,0x4c7b,[ 0xB2,0xD0,0xE0,0x33,0x7B,0xC6,0x1F,0x8C ] };

    // Notify the package that an attempt was made to load symbols
    // for pModule
    HRESULT GetSymbolSearchInfo(
        /+[out]+/ IDebugModule3 * pModule,
        // Optional message that describes the event
        /+[in, out]+/ BSTR* pbstrDebugMessage,
        // Flag denoting if symbols were loaded
        /+[out]+/ MODULE_INFO_FLAGS* pdwModuleInfoFlags);
}
enum /+ enum_MODULE_INFO_FLAGS+/ : DWORD 
{
        MIF_SYMBOLS_LOADED      = 0x0001,
}
alias DWORD enum_MODULE_INFO_FLAGS;
alias DWORD MODULE_INFO_FLAGS;;

// ------------------------------------------------------------------
// 
// IDebugBeforeSymbolSearchEvent2
const GUID IID_IDebugBeforeSymbolSearchEvent2 = IDebugBeforeSymbolSearchEvent2.iid;

interface IDebugBeforeSymbolSearchEvent2 : IUnknown
{
    static const GUID iid = { 0xB15C8149,0x2B81,0x40ae,[ 0x93,0x88,0x62,0xFA,0x27,0x6A,0xE1,0x4C ] };
    HRESULT GetModuleName(
        /+[out]+/ BSTR* pbstrModuleName
        );
};

// ------------------------------------------------------------------
// IDebugPropertyCreateEvent2
const GUID IID_IDebugPropertyCreateEvent2 = IDebugPropertyCreateEvent2.iid;

interface IDebugPropertyCreateEvent2 : IUnknown
{
    static const GUID iid = { 0xded6d613,0xa3db,0x4e35,[ 0xbb,0x5b,0xa9,0x23,0x91,0x13,0x3f,0x03 ] };
    HRESULT GetDebugProperty(
        /+[out]+/ IDebugProperty2 * ppProperty);
};

// ------------------------------------------------------------------
// IDebugPropertyDestroyEvent2
const GUID IID_IDebugPropertyDestroyEvent2 = IDebugPropertyDestroyEvent2.iid;

interface IDebugPropertyDestroyEvent2 : IUnknown
{
    static const GUID iid = { 0xf3765f18,0xf395,0x4b8c,[ 0x8e,0x95,0xdc,0xb3,0xfe,0x8e,0x7e,0xc8 ] };
    HRESULT GetDebugProperty(
        /+[out]+/ IDebugProperty2 * ppProperty);
};

// ------------------------------------------------------------------
// IDebugBreakpointBoundEvent2

const GUID IID_IDebugBreakpointBoundEvent2 = IDebugBreakpointBoundEvent2.iid;

interface IDebugBreakpointBoundEvent2 : IUnknown
{
    static const GUID iid = { 0x1dddb704,0xcf99,0x4b8a,[ 0xb7,0x46,0xda,0xbb,0x01,0xdd,0x13,0xa0 ] };
    HRESULT GetPendingBreakpoint(
        /+[out]+/ IDebugPendingBreakpoint2 * ppPendingBP);

    HRESULT EnumBoundBreakpoints(
        /+[out]+/ IEnumDebugBoundBreakpoints2 * ppEnum);
};

// ------------------------------------------------------------------
// IDebugBreakpointUnboundEvent2

const GUID IID_IDebugBreakpointUnboundEvent2 = IDebugBreakpointUnboundEvent2.iid;

interface IDebugBreakpointUnboundEvent2 : IUnknown
{
    static const GUID iid = { 0x78d1db4f,0xc557,0x4dc5,[ 0xa2,0xdd,0x53,0x69,0xd2,0x1b,0x1c,0x8c ] };

    HRESULT GetBreakpoint(
        /+[out]+/ IDebugBoundBreakpoint2 * ppBP);

    HRESULT GetReason(
        /+[out]+/ BP_UNBOUND_REASON* pdwUnboundReason);
}
enum /+ enum_BP_UNBOUND_REASON+/ : DWORD 
{
        BPUR_UNKNOWN            = 0x0001,
        BPUR_CODE_UNLOADED        = 0x0002,
        // BPUR_BREAKPOINT_REBIND means the breakpoint is being unbound
        // because it is being rebound to a different location. (For example,
        // this can happen after an ENC when the breakpoint moves, or if this
        // breakpoint was originally bound with a less than perfect file
        // name match.) Generally, the IDE will discard any persisted information
        // about this breakpoint.
        BPUR_BREAKPOINT_REBIND    = 0x0003,
        // BPUR_BREAKPOINT_ERROR means that the breakpoint was deemed to be in error
        // after it was bound.  This will happen for managed bps whose condition is
        // not valid.
        BPUR_BREAKPOINT_ERROR   = 0x0004
}
alias DWORD enum_BP_UNBOUND_REASON;
alias DWORD BP_UNBOUND_REASON;;

// ------------------------------------------------------------------
// IDebugBreakpointErrorEvent2

const GUID IID_IDebugBreakpointErrorEvent2 = IDebugBreakpointErrorEvent2.iid;

interface IDebugBreakpointErrorEvent2 : IUnknown
{
    static const GUID iid = { 0xabb0ca42,0xf82b,0x4622,[ 0x84,0xe4,0x69,0x03,0xae,0x90,0xf2,0x10 ] };
    HRESULT GetErrorBreakpoint(
        /+[out]+/ IDebugErrorBreakpoint2 * ppErrorBP);
};

// ------------------------------------------------------------------
// IDebugExpressionEvaluationCompleteEvent2
const GUID IID_IDebugExpressionEvaluationCompleteEvent2 = IDebugExpressionEvaluationCompleteEvent2.iid;

interface IDebugExpressionEvaluationCompleteEvent2 : IUnknown
{
    static const GUID iid = { 0xc0e13a85,0x238a,0x4800,[ 0x83,0x15,0xd9,0x47,0xc9,0x60,0xa8,0x43 ] };
    HRESULT GetExpression(
        /+[out]+/ IDebugExpression2 * ppExpr);

    HRESULT GetResult(
        /+[out]+/ IDebugProperty2 * ppResult);
};

// ------------------------------------------------------------------
// IDebugReturnValueEvent2
const GUID IID_IDebugReturnValueEvent2 = IDebugReturnValueEvent2.iid;

interface IDebugReturnValueEvent2 : IUnknown
{
    static const GUID iid = { 0x0da4d4cc,0x2d0b,0x410f,[ 0x8d,0x5d,0xb6,0xb7,0x3a,0x5d,0x35,0xd8 ] };
    HRESULT    GetReturnValue(
        /+[out]+/ IDebugProperty2 * ppReturnValue);
};

// ------------------------------------------------------------------
// IDebugNoSymbolsEvent2
const GUID IID_IDebugNoSymbolsEvent2 = IDebugNoSymbolsEvent2.iid;

interface IDebugNoSymbolsEvent2 : IUnknown
{
    static const GUID iid = { 0x3ad4fb48,0x647e,0x4b03,[ 0x9c,0x1e,0x52,0x75,0x4e,0x80,0xc8,0x80 ] };
};

// ------------------------------------------------------------------
// IDebugProgramNameChangedEvent2
const GUID IID_IDebugProgramNameChangedEvent2 = IDebugProgramNameChangedEvent2.iid;

interface IDebugProgramNameChangedEvent2 : IUnknown
{
    static const GUID iid = { 0xe05c2dfd,0x59d5,0x46d3,[ 0xa7,0x1c,0x5d,0x07,0x66,0x5d,0x85,0xaf ] };
};

// ------------------------------------------------------------------
// IDebugThreadNameChangedEvent2
const GUID IID_IDebugThreadNameChangedEvent2 = IDebugThreadNameChangedEvent2.iid;

interface IDebugThreadNameChangedEvent2 : IUnknown
{
    static const GUID iid = { 0x1ef4ef78,0x2c44,0x4b7a,[ 0x84,0x73,0x8f,0x43,0x57,0x61,0x17,0x29 ] };
};

// ------------------------------------------------------------------
// IDebugMessageEvent2
const GUID IID_IDebugMessageEvent2 = IDebugMessageEvent2.iid;

interface IDebugMessageEvent2 : IUnknown
{
    static const GUID iid = { 0x3bdb28cf,0xdbd2,0x4d24,[ 0xaf,0x03,0x01,0x07,0x2b,0x67,0xeb,0x9e ] };

    HRESULT GetMessage(
        /+[out]+/ MESSAGETYPE* pMessageType,
        /+[out]+/ BSTR* pbstrMessage,
        // Use the MB_* constants
        /+[out]+/ DWORD* pdwType,
        /+[out]+/ BSTR* pbstrHelpFileName,
        /+[out]+/ DWORD* pdwHelpId);

    HRESULT SetResponse(
        in DWORD dwResponse);
}
enum /+ enum_MESSAGETYPE+/ : DWORD 
{
        // the following values indicate the how to display the message
        MT_OUTPUTSTRING      = 0x00000001, // output a message to the Output window
        MT_MESSAGEBOX        = 0x00000002, // display a message box 
        MT_TYPE_MASK         = 0x000000FF,

        // the following values provides reasons for the message
        MT_REASON_EXCEPTION  = 0x00000100,
        MT_REASON_TRACEPOINT = 0x00000200,
        MT_REASON_MASK       = 0x0000FF00,
}
alias DWORD enum_MESSAGETYPE;
alias DWORD MESSAGETYPE;;

// ------------------------------------------------------------------
// IDebugErrorEvent2
const GUID IID_IDebugErrorEvent2 = IDebugErrorEvent2.iid;

interface IDebugErrorEvent2 : IUnknown
{
    static const GUID iid = { 0xfdb7a36c,0x8c53,0x41da,[ 0xa3,0x37,0x8b,0xd8,0x6b,0x14,0xd5,0xcb ] };
    // Note: format should be of the form:
    //    "Unable to stand on my head. %1"
    HRESULT GetErrorMessage(
        /+[out]+/ MESSAGETYPE* pMessageType,
        /+[out]+/ BSTR* pbstrErrorFormat,
        /+[out]+/ HRESULT* phrErrorReason,
        // Use the MB_* constants
        /+[out]+/ DWORD* pdwType,
        /+[out]+/ BSTR* pbstrHelpFileName,
        /+[out]+/ DWORD* pdwHelpId);
};

// ------------------------------------------------------------------
// IDebugActivateDocumentEvent2
const GUID IID_IDebugActivateDocumentEvent2 = IDebugActivateDocumentEvent2.iid;

interface IDebugActivateDocumentEvent2 : IUnknown
{
    static const GUID iid = { 0x58f36c3d,0x7d07,0x4eba,[ 0xa0,0x41,0x62,0xf6,0x3e,0x18,0x80,0x37 ] };
    HRESULT GetDocument(
        /+[out]+/ IDebugDocument2 * ppDoc);

    HRESULT GetDocumentContext(
        /+[out]+/ IDebugDocumentContext2 * ppDocContext);
};

// ------------------------------------------------------------------
// IDebugInterceptExceptionCompleteEvent2
const GUID IID_IDebugInterceptExceptionCompleteEvent2 = IDebugInterceptExceptionCompleteEvent2.iid;

interface IDebugInterceptExceptionCompleteEvent2 : IUnknown
{
    static const GUID iid = { 0x44FCEACA,0x7F56,0x4d2c,[ 0xA6,0x37,0x60,0x05,0x2B,0x1B,0x9C,0xBE ] };
    HRESULT GetInterceptCookie(
        /+[out]+/ UINT64* pqwCookie);
};

// ------------------------------------------------------------------
// IDebugAttachCompleteEvent2
const GUID IID_IDebugAttachCompleteEvent2 = IDebugAttachCompleteEvent2.iid;

interface IDebugAttachCompleteEvent2 : IUnknown
{
    static const GUID iid = { 0xfe1fd9ea,0x6413,0x4183,[ 0xa6,0x7d,0x58,0x88,0x70,0x01,0x4e,0x97 ] };
};

// ------------------------------------------------------------------
// IDebugFuncEvalAbortedEvent2
const GUID IID_IDebugFuncEvalAbortedEvent2 = IDebugFuncEvalAbortedEvent2.iid;

interface IDebugFuncEvalAbortedEvent2 : IUnknown
{
    static const GUID iid = { 0x3f3be369,0x0b78,0x4511,[ 0x91,0xe5,0x08,0xf9,0xfc,0x5c,0xae,0x0d ] };

    HRESULT GetAbortResult(
        /+[out]+/ FUNC_EVAL_ABORT_RESULT* pResult);

    HRESULT GetFunctionName(
        /+[out]+/ BSTR* pbstrFunctionName);
}
enum /+ tagFUNC_EVAL_ABORT_RESULT+/ : int 
{
        ABORT_SUCCEEDED = 0,
        RUDE_ABORT_SUCCEEDED = 1,
        ABORT_FAILED = 2,
        ABORT_HUNG = 3,
        PROCESS_TERMINATED = 4
}
alias int tagFUNC_EVAL_ABORT_RESULT;
alias  tagFUNC_EVAL_ABORT_RESULT FUNC_EVAL_ABORT_RESULT;;

// ------------------------------------------------------------------
// IDebugStopCompleteEvent2
const GUID IID_IDebugStopCompleteEvent2 = IDebugStopCompleteEvent2.iid;

interface IDebugStopCompleteEvent2 : IUnknown
{
    static const GUID iid = { 0x3dca9dcd,0xfb09,0x4af1,[ 0xa9,0x26,0x45,0xf2,0x93,0xd4,0x8b,0x2d ] };
};

enum /+ tagEncUnavailableReason+/ : int 
{
    ENCUN_NONE,
    ENCUN_INTEROP,
    ENCUN_SQLCLR,
    ENCUN_MINIDUMP,
    ENCUN_EMBEDDED,
    ENCUN_ATTACH,
    ENCUN_WIN64,
    ENCUN_STOPONEMODE,
    ENCUN_MODULENOTLOADED,
    ENCUN_MODULERELOADED,
    ENCUN_INRUNMODE,
    ENCUN_NOTBUILT,
    ENCUN_REMOTE,
    ENCUN_SILVERLIGHT,
    ENCUN_ENGINE_METRIC_FALSE,
    ENCUN_NOT_ALLOWED_FOR_MODULE,
    ENCUN_NOT_SUPPORTED_FOR_CLR64_VERSION
}
alias int tagEncUnavailableReason;
alias  tagEncUnavailableReason EncUnavailableReason;

// The VSdebug Package implements this interface.
const GUID IID_IDebugEncNotify = IDebugEncNotify.iid;

interface IDebugEncNotify : IUnknown
{
    static const GUID iid = { 0x347C45E1,0x5C42,0x4e0e,[ 0x9E,0x15,0xDE,0xFF,0x9C,0xFC,0x78,0x41 ] };
    // This method allows the ENCManager to tell the package that ENC
    // is not available as soon as it can be determined rather than waiting for a call from the package.
    HRESULT NotifyEncIsUnavailable(
        in EncUnavailableReason reason,
        in BOOL fEditWasApplied);

    // This method allows the Lang Serice to Notify the package that the Current Statement 
    // must be updated due to an edit.
    HRESULT NotifyEncUpdateCurrentStatement();

    // This method allows the Lang Service to Notify the package that an edit was attempted
    // when the debuggee is in a state that cannot accept changes.
    HRESULT NotifyEncEditAttemptedAtInvalidStopState();

    // This allows the Lang Service or project to tell the package that it prevented
    // an edit from occuring.
    // The package is responsible for asking the ENC manager why ENC would not be 
    // allowed at this point.
    HRESULT NotifyEncEditDisallowedByProject(
        /+[in]+/ IUnknown pProject);
}

// ------------------------------------------------------------------
// IDebugSessionEvent2 - implemented by all SDM events (such as session
// create/destroy)
const GUID IID_IDebugSessionEvent2 = IDebugSessionEvent2.iid;

interface IDebugSessionEvent2 : IUnknown
{
    static const GUID iid = { 0xfd1a378c,0xf117,0x4f43,[ 0x91,0x7c,0xda,0xdc,0xa1,0x30,0x86,0x06 ] };
    HRESULT GetSession(
        /+[out]+/ IDebugSession2 *ppSession);
};

// ------------------------------------------------------------------
// IDebugProcess2
const GUID IID_IDebugProcess2 = IDebugProcess2.iid;

interface IDebugProcess2 : IUnknown
{
    static const GUID iid = { 0x43286fea,0x6997,0x4543,[ 0x80,0x3e,0x60,0xa2,0x0c,0x47,0x3d,0xe5 ] };

    HRESULT GetInfo(
        in PROCESS_INFO_FIELDS Fields,
        /+[out]+/ PROCESS_INFO* pProcessInfo);

    HRESULT EnumPrograms(
        /+[out]+/ IEnumDebugPrograms2 * ppEnum);

    HRESULT GetName(
        in GETNAME_TYPE gnType,
        /+[out]+/ BSTR* pbstrName);

    HRESULT GetServer(
        /+[out]+/ IDebugCoreServer2 * ppServer);

    HRESULT Terminate();

    HRESULT Attach(
        /+[in]+/ IDebugEventCallback2 pCallback,
        /+[ size_is (celtSpecificEngines)]+/ in GUID* rgguidSpecificEngines,
        in DWORD celtSpecificEngines,
        /+[out, size_is(celtSpecificEngines), length_is(celtSpecificEngines)]+/ HRESULT* rghrEngineAttach);

    HRESULT CanDetach();

    HRESULT Detach();

    HRESULT GetPhysicalProcessId(
        /+[out]+/ AD_PROCESS_ID* pProcessId);

    HRESULT GetProcessId(
        /+[out]+/ GUID* pguidProcessId);

    HRESULT GetAttachedSessionName(
        /+[out]+/ BSTR* pbstrSessionName);

    // Get a list of threads in this process (no duplicates)
    HRESULT EnumThreads(
        /+[out]+/ IEnumDebugThreads2 * ppEnum);

    HRESULT CauseBreak();

    HRESULT GetPort(
        /+[out]+/ IDebugPort2 * ppPort);
}
enum /+ enum_PROCESS_INFO_FLAGS+/ : DWORD 
{
        PIFLAG_SYSTEM_PROCESS        = 0x00000001,
        PIFLAG_DEBUGGER_ATTACHED    = 0x00000002,
        // The flags below are only valid in VS8 and above
        // and are only set when PIFLAG_DEBUGGER_ATTACHED
        // is set.
        PIFLAG_PROCESS_STOPPED        = 0x00000004,
        PIFLAG_PROCESS_RUNNING        = 0x00000008,
}
alias DWORD enum_PROCESS_INFO_FLAGS;
alias DWORD PROCESS_INFO_FLAGS;
enum /+ enum_PROCESS_INFO_FIELDS+/ : DWORD 
{
        PIF_FILE_NAME                = 0x00000001,
        PIF_BASE_NAME                = 0x00000002,
        PIF_TITLE                    = 0x00000004,
        PIF_PROCESS_ID                = 0x00000008,
        PIF_SESSION_ID                = 0x00000010,
        PIF_ATTACHED_SESSION_NAME    = 0x00000020,
        PIF_CREATION_TIME            = 0x00000040,
        PIF_FLAGS                    = 0x00000080,

        PIF_ALL                        = 0x000000ff,
}
alias DWORD enum_PROCESS_INFO_FIELDS;
alias DWORD PROCESS_INFO_FIELDS;
struct tagPROCESS_INFO
{
        // Valid fields
        PROCESS_INFO_FIELDS    Fields;
        // Full path+file name+extension; equivalent to calling GetName(GN_FILENAME, ...)
        BSTR                bstrFileName;
        // File name+extension; equivalent to calling GetName(GN_BASENAME, ...)
        BSTR                bstrBaseName;
        // Title (if one exists); equivalent to calling GetName(GN_TITLE, ...)
        BSTR                bstrTitle;
        // Process id; equivalent to calling GetPhysicalProcessId
        AD_PROCESS_ID        ProcessId;
        // Session id: the system session that this process is running in
        DWORD                dwSessionId;
        // Attached session name (if one exists); equivalent to calling GetAttachedSessionName
        BSTR                bstrAttachedSessionName;
        // Time the process was created
        FILETIME            CreationTime;
        // Flags
        PROCESS_INFO_FLAGS    Flags;
}
alias tagPROCESS_INFO PROCESS_INFO;;

const GUID IID_IDebugProcess3 = IDebugProcess3.iid;

interface IDebugProcess3 : IDebugProcess2
{
    static const GUID iid = { 0x83ab1712,0x18a6,0x47a1,[ 0x8d,0xa6,0x8c,0x7b,0x0f,0x96,0x09,0x2e ] };

    // Execute the process. The thread is given so that the debugger
    // knows which thread the user is viewing when executing.
    HRESULT Execute(
        /+[in]+/ IDebugThread2 pThread);

    // Continue the process in whatever state is was previously in. If
    // the process was stepping, then continue the step; otherwise,
    // continue execution.
    HRESULT Continue(
        /+[in]+/ IDebugThread2 pThread);

    // Step the process. The thread specified is stepped and all other
    // threads in the process run.
    HRESULT Step(
        /+[in]+/ IDebugThread2 pThread,
        in STEPKIND sk,
        in STEPUNIT step);

    HRESULT GetDebugReason(
        /+[out]+/ DEBUG_REASON *pReason);

    // Provide a way to indicate the HostingProcessLanguage so that the managed
    // debug engine can preload the right EE.
    HRESULT SetHostingProcessLanguage(in GUID* guidLang);
    HRESULT GetHostingProcessLanguage(/+[out]+/ GUID* pguidLang);

    // Provide a mechanism for the Package to explicitly disable ENC.
    // EncUnavailableReason is defined in enc.idl
    HRESULT DisableENC(
        in EncUnavailableReason reason);
    HRESULT GetENCAvailableState(
        /+[out]+/EncUnavailableReason* preason);

    HRESULT GetEngineFilter(
        /+[out]+/ GUID_ARRAY *pEngineArray);
}
enum /+ enum_STEPKIND+/ : DWORD 
{
        STEP_INTO,
        STEP_OVER,
        STEP_OUT,
        STEP_BACKWARDS
}
alias DWORD enum_STEPKIND;
alias DWORD STEPKIND;
enum /+ enum_STEPUNIT+/ : DWORD 
{
        STEP_STATEMENT,
        STEP_LINE,
        STEP_INSTRUCTION,
}
alias DWORD enum_STEPUNIT;
alias DWORD STEPUNIT;
enum /+ enum_DEBUG_REASON+/ : DWORD 
{
        DEBUG_REASON_ERROR,
        DEBUG_REASON_USER_LAUNCHED,
        DEBUG_REASON_USER_ATTACHED,
        DEBUG_REASON_AUTO_ATTACHED,
        DEBUG_REASON_CAUSALITY
}
alias DWORD enum_DEBUG_REASON;
alias DWORD DEBUG_REASON;;

const GUID IID_IDebugProcessSecurity2 = IDebugProcessSecurity2.iid;

interface IDebugProcessSecurity2 : IUnknown
{
    static const GUID iid = { 0xfca0c35c,0x4c02,0x432b,[ 0x88,0xf7,0xeb,0x27,0x7b,0xe2,0xba,0x55 ] };
    HRESULT QueryCanSafelyAttach(
        );

    HRESULT GetUserName(
        /+[out]+/ BSTR *pbstrUserName
        );
};

// ------------------------------------------------------------------
// IDebugProgram2
const GUID IID_IDebugProgram2 = IDebugProgram2.iid;

interface IDebugProgram2 : IUnknown
{
    static const GUID iid = { 0x69d172ef,0xf2c4,0x44e1,[ 0x89,0xf7,0xc8,0x62,0x31,0xe7,0x06,0xe9 ] };

    HRESULT EnumThreads(
        /+[out]+/ IEnumDebugThreads2 * ppEnum);

    HRESULT GetName(
        /+[out]+/ BSTR* pbstrName);

    HRESULT GetProcess(
        /+[out]+/ IDebugProcess2 * ppProcess);

    HRESULT Terminate();

    HRESULT Attach(
        /+[in]+/ IDebugEventCallback2 pCallback);

    HRESULT CanDetach();

    HRESULT Detach();

    HRESULT GetProgramId(
        /+[out]+/ GUID* pguidProgramId);

    HRESULT GetDebugProperty(
        /+[out]+/ IDebugProperty2 * ppProperty);

    // To execute during an expression evaluation, use IDebugProcess3::
    // Execute. Execution during expression evaluation requires
    // a thread so that the correct expression evaluation can be continued.
    HRESULT Execute();

    // Continue, preserving state
    HRESULT Continue(
        /+[in]+/ IDebugThread2 pThread);

    HRESULT Step(
        /+[in]+/ IDebugThread2 pThread,
        in STEPKIND sk,
        in STEPUNIT step);

    HRESULT CauseBreak();

    HRESULT GetEngineInfo(
        /+[out]+/ BSTR* pbstrEngine,
        /+[out]+/ GUID* pguidEngine);

    HRESULT EnumCodeContexts(
        /+[in]+/ IDebugDocumentPosition2 pDocPos,
        /+[out]+/ IEnumDebugCodeContexts2 * ppEnum);

    HRESULT GetMemoryBytes(
        /+[out]+/ IDebugMemoryBytes2 * ppMemoryBytes);

    HRESULT GetDisassemblyStream(
        in DISASSEMBLY_STREAM_SCOPE dwScope,
        /+[in]+/ IDebugCodeContext2 pCodeContext,
        /+[out]+/ IDebugDisassemblyStream2 * ppDisassemblyStream);

    HRESULT EnumModules(
        /+[out]+/ IEnumDebugModules2 * ppEnum);

    HRESULT GetENCUpdate(
        /+[out]+/ IDebugENCUpdate** ppUpdate);

    HRESULT EnumCodePaths(
        /+[ ptr]+/ in LPCOLESTR pszHint,
        /+[in]+/ IDebugCodeContext2 pStart,
        /+[in]+/ IDebugStackFrame2 pFrame,
        in BOOL fSource,
        /+[out]+/ IEnumCodePaths2 * ppEnum,
        /+[out]+/ IDebugCodeContext2 * ppSafety);

    HRESULT WriteDump(
        in DUMPTYPE DumpType,
        in LPCOLESTR pszDumpUrl
        );
}
enum /+ enum_DISASSEMBLY_STREAM_SCOPE+/ : DWORD 
{
        DSS_HUGE        = 0x10000000,
        // Get the disasm for the function contained by the code context
        DSS_FUNCTION    = 0x0001,        
        // Get the disasm for the module contained by the code context
        DSS_MODULE        = (DSS_HUGE) | 0x0002,
        // Get the disasm for the entire address space
        DSS_ALL            = (DSS_HUGE) | 0x0003
}
alias DWORD enum_DISASSEMBLY_STREAM_SCOPE;
alias DWORD DISASSEMBLY_STREAM_SCOPE;
enum /+ enum_DUMPTYPE+/ : DWORD 
{
        // "mini" dump of the program state
        DUMP_MINIDUMP,
        // full dump of the program state
        DUMP_FULLDUMP,
}
alias DWORD enum_DUMPTYPE;
alias DWORD DUMPTYPE;
struct tagCODE_PATH
{
        BSTR bstrName;
        IDebugCodeContext2 pCode;
}
alias tagCODE_PATH CODE_PATH;;

// ------------------------------------------------------------------
// IDebugProgram3
const GUID IID_IDebugProgram3 = IDebugProgram3.iid;

interface IDebugProgram3 : IDebugProgram2
{
    static const GUID iid = { 0x7CF3EC7F,0xAC62,0x4cd6,[ 0xBB,0x30,0x39,0xA4,0x64,0xCB,0x52,0xCB ] };
    // Execute the program. The thread is given so that the debugger
    // knows which thread the user is viewing when executing.
    HRESULT ExecuteOnThread(
        /+[in]+/ IDebugThread2 pThread);
};

// ------------------------------------------------------------------
// IDebugEngineProgram2
const GUID IID_IDebugEngineProgram2 = IDebugEngineProgram2.iid;

interface IDebugEngineProgram2 : IUnknown
{
    static const GUID iid = { 0x7ce3e768,0x654d,0x4ba7,[ 0x8d,0x95,0xcd,0xaa,0xc6,0x42,0xb1,0x41 ] };

    // Stop all threads running in this program
    HRESULT Stop();

    HRESULT WatchForThreadStep(
        /+[in]+/ IDebugProgram2 pOriginatingProgram,
        in DWORD dwTid,
        in BOOL fWatch,
        in DWORD dwFrame);

    HRESULT WatchForExpressionEvaluationOnThread(
        /+[in]+/ IDebugProgram2 pOriginatingProgram,
        in DWORD dwTid,
        in DWORD dwEvalFlags,
        // pExprCallback must be NULL in V8 and above
        /+[in]+/ IDebugEventCallback2 pExprCallback,
        in BOOL fWatch);
}
enum /+ enum_WATCHFOREVAL+/ : int 
{
        // the program being notified is the leaf program (it owns the leaf frame)
        WATCHFOREVAL_LEAF_PROGRAM = 0x10000000
}
alias int enum_WATCHFOREVAL;;

// ------------------------------------------------------------------
// IDebugProgramHost2
const GUID IID_IDebugProgramHost2 = IDebugProgramHost2.iid;

interface IDebugProgramHost2 : IUnknown
{
    static const GUID iid = { 0xc99d588f,0x778c,0x44fe,[ 0x8b,0x2e,0x40,0x12,0x4a,0x73,0x88,0x91 ] };
    HRESULT GetHostName(
        in DWORD dwType,
        /+[out]+/ BSTR* pbstrHostName);

    HRESULT GetHostId(
        /+[out]+/ AD_PROCESS_ID* pProcessId);

    HRESULT GetHostMachineName(
        /+[out]+/ BSTR* pbstrHostMachineName);
};

// ------------------------------------------------------------------
// IDebugProgramNode2
const GUID IID_IDebugProgramNode2 = IDebugProgramNode2.iid;

interface IDebugProgramNode2 : IUnknown
{
    static const GUID iid = { 0x426e255c,0xf1ce,0x4d02,[ 0xa9,0x31,0xf9,0xa2,0x54,0xbf,0x7f,0x0f ] };

    HRESULT GetProgramName(
        /+[out]+/ BSTR* pbstrProgramName);

    HRESULT GetHostName(
        in GETHOSTNAME_TYPE dwHostNameType,
        /+[out]+/ BSTR* pbstrHostName);

    HRESULT GetHostPid(
        /+[out]+/ AD_PROCESS_ID* pHostProcessId);

    // method is no longer used, and does not need to be implemented
    HRESULT GetHostMachineName_V7(
        /+[out]+/ BSTR* pbstrHostMachineName);

    // method is no longer used, and should not be implemented
    HRESULT Attach_V7(
        /+[in]+/ IDebugProgram2 pMDMProgram,
        /+[in]+/ IDebugEventCallback2 pCallback,
        in DWORD dwReason);

    HRESULT GetEngineInfo(
        /+[out]+/ BSTR* pbstrEngine,
        /+[out]+/ GUID* pguidEngine);

    // method is no longer used, and should not be implemented
    HRESULT DetachDebugger_V7();
}
enum /+ enum_GETHOSTNAME_TYPE+/ : DWORD 
{
        GHN_FRIENDLY_NAME,    // Gets friendly name of the host
        GHN_FILE_NAME,
}
alias DWORD enum_GETHOSTNAME_TYPE;
alias DWORD GETHOSTNAME_TYPE;;

const GUID IID_IDebugProgramNodeAttach2 = IDebugProgramNodeAttach2.iid;

interface IDebugProgramNodeAttach2 : IUnknown
{
    static const GUID iid = { 0x73faa608,0x5f87,0x4d2b,[ 0x95,0x51,0x84,0x40,0xb1,0xcb,0xf5,0x4c ] };
    // This is the whidbey replacement for IDebugProgramNode2::Attach.
    // This gives a program node a chance to say that it doesn't want
    // to be debugged, and to know the program id on the port
    // supplier program
    HRESULT OnAttach(
        in GUID* guidProgramId);
};

// ------------------------------------------------------------------
// IDebugProgramEngines2
//
// IDebugProgramEngines2 is implemented by program nodes to indicate
// all the possible DEs that can debug this program. Once a DE is
// chosen (via some UI) that choice is registered by calling SetEngine.
// This engine will then be the engine returned by
// IDebugProgramNode::GetEngineInfo.
const GUID IID_IDebugProgramEngines2 = IDebugProgramEngines2.iid;

interface IDebugProgramEngines2 : IUnknown
{
    static const GUID iid = { 0xfda24a6b,0xb142,0x447d,[ 0xbb,0xbc,0x86,0x54,0xa3,0xd8,0x4f,0x80 ] };
    // In order to determine how many engines there are, call once
    // with celtBuffer set to 0 and rgguidEngines set to NULL. This
    // function will return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
    // anytime the buffer is too small and *pceltEngines will contain
    // the necessary size of the buffer.
    HRESULT EnumPossibleEngines(
        in DWORD celtBuffer,
        /+[in, out, ptr, size_is(celtBuffer), length_is(*pceltEngines)]+/ GUID* rgguidEngines,
        /+[in, out]+/ DWORD* pceltEngines);

    // Tell the program/program node which engine to use for debugging this program
    HRESULT SetEngine(
        in GUID* guidEngine);
};

// ------------------------------------------------------------------
// IDebugCOMPlusProgramNode2
const GUID IID_IDebugCOMPlusProgramNode2 = IDebugCOMPlusProgramNode2.iid;

interface IDebugCOMPlusProgramNode2 : IUnknown
{
    static const GUID iid = { 0xd6f7d3d0,0x506a,0x448f,[ 0x87,0x02,0x46,0xeb,0x27,0x45,0xe4,0xfc ] };
    HRESULT GetAppDomainId(
        /+[out]+/ ULONG32* pul32Id);
};

// ------------------------------------------------------------------
// IDebugSQLCLRProgramNode2
const GUID IID_IDebugSQLCLRProgramNode2 = IDebugSQLCLRProgramNode2.iid;

interface IDebugSQLCLRProgramNode2 : IUnknown
{
    static const GUID iid = { 0xF617DFCB,0x0045,0x4024,[ 0x83,0x7B,0x7A,0xCA,0xD8,0xF4,0xD6,0x7B ] };
    HRESULT GetConnectionId(
        /+[out]+/ DWORD* pdwId);
};

// ------------------------------------------------------------------
// IDebugThread2
const GUID IID_IDebugThread2 = IDebugThread2.iid;

interface IDebugThread2 : IUnknown
{
    static const GUID iid = { 0xd5168050,0xa57a,0x465c,[ 0xbe,0xa9,0x97,0x4f,0x40,0x5e,0xba,0x13 ] };

    HRESULT EnumFrameInfo(
        in  FRAMEINFO_FLAGS dwFieldSpec,
        in  UINT nRadix,
        /+[out]+/ IEnumDebugFrameInfo2 * ppEnum);

    HRESULT GetName(
        /+[out]+/ BSTR* pbstrName);

    HRESULT SetThreadName(
        in LPCOLESTR pszName);

    HRESULT GetProgram(
        /+[out]+/ IDebugProgram2 * ppProgram);

    HRESULT CanSetNextStatement(
        /+[in]+/ IDebugStackFrame2 pStackFrame,
        /+[in]+/ IDebugCodeContext2 pCodeContext);

    HRESULT SetNextStatement (
        /+[in]+/ IDebugStackFrame2 pStackFrame,
        /+[in]+/ IDebugCodeContext2 pCodeContext);

    HRESULT GetThreadId(
        /+[out]+/ DWORD* pdwThreadId);

    HRESULT Suspend(
        /+[out]+/ DWORD *pdwSuspendCount);

    HRESULT Resume(
        /+[out]+/ DWORD *pdwSuspendCount);

    HRESULT GetThreadProperties(
        in THREADPROPERTY_FIELDS dwFields,
        /+[out]+/ THREADPROPERTIES *ptp);

    HRESULT GetLogicalThread(
        /+[in]+/ IDebugStackFrame2 pStackFrame,
        /+[out]+/ IDebugLogicalThread2 *ppLogicalThread);
}
enum /+ enum_THREADSTATE+/ : DWORD 
{
        // The thread is running
        THREADSTATE_RUNNING        = 0x0001,
        // The thread is stopped because of a breakpoint
        THREADSTATE_STOPPED        = 0x0002,
        // The thread has been created, but is not yet running code
        THREADSTATE_FRESH        = 0x0003,
        // The thread is dead
        THREADSTATE_DEAD        = 0x0004,
        // The thread is frozen (no execution can be performed)
        THREADSTATE_FROZEN        = 0x0005,
}
alias DWORD enum_THREADSTATE;
alias DWORD THREADSTATE;
enum /+ enum_THREADPROPERTY_FIELDS+/ : DWORD 
{
        TPF_ID                = 0x0001,
        TPF_SUSPENDCOUNT    = 0x0002,
        TPF_STATE            = 0x0004,
        TPF_PRIORITY        = 0x0008,
        TPF_NAME            = 0x0010,
        TPF_LOCATION        = 0x0020,

        TPF_ALLFIELDS        = 0xffffffff,
}
alias DWORD enum_THREADPROPERTY_FIELDS;
alias DWORD THREADPROPERTY_FIELDS;
struct _tagTHREADPROPERTIES
{
        THREADPROPERTY_FIELDS dwFields;
        DWORD dwThreadId;
        DWORD dwSuspendCount;
        DWORD dwThreadState;
        BSTR bstrPriority;
        BSTR bstrName;
        BSTR bstrLocation;
}
alias _tagTHREADPROPERTIES THREADPROPERTIES;
enum /+ enum_FRAMEINFO_FLAGS+/ : DWORD 
{
        // FRAMEINFO fields
        FIF_FUNCNAME                = 0x00000001,
        FIF_RETURNTYPE                = 0x00000002,
        FIF_ARGS                    = 0x00000004,
        FIF_LANGUAGE                = 0x00000008,
        FIF_MODULE                    = 0x00000010, // The name of the module (m_bstrModule)
        FIF_STACKRANGE                 = 0x00000020,
        FIF_FRAME                    = 0x00000040,
        FIF_DEBUGINFO                = 0x00000080,
        FIF_STALECODE                = 0x00000100,
        FIF_FLAGS                    = 0x00000200,
        FIF_DEBUG_MODULEP           = 0x00000400, // the IDebugModule2* for this frame. (m_pModule)

        // Function name formatting

        // Fill in the m_bstrFuncName field as a single string using all the flags specified below
        // Specifying FIF_FUNCNAME | FIF_FUNCNAME_FORMAT | FIF_FUNCNAME_RETURNTYPE | FIF_FUNCNAME_ARGS | FIF_FUNCNAME_ARGS_TYPE | FIF_FUNCNAME_ARGS_NAMES | FIF_FUNCNAME_ARGS_VALUES
        // Results in: int CFoo::foo(int x = 1, int y = 2)

        FIF_FUNCNAME_FORMAT         = 0x00001000,
        // Add the return type to the formatted function name
        FIF_FUNCNAME_RETURNTYPE     = 0x00002000,
        // Add the args to the formatted function name
        FIF_FUNCNAME_ARGS           = 0x00004000,
        // Add the language to the formatted function name
        FIF_FUNCNAME_LANGUAGE       = 0x00008000,
        // Add the module name to the formatted function name
        FIF_FUNCNAME_MODULE         = 0x00010000,
        // Add the number of lines to the end of the function name
        FIF_FUNCNAME_LINES          = 0x00020000,
        // Add the bytes offset to the end of the function name
        FIF_FUNCNAME_OFFSET         = 0x00040000,

        // Function name argument formatting

        // Format the args in the formatted function name (example: (x = 3, y = 4))
        FIF_FUNCNAME_ARGS_TYPES        = 0x00100000,
        FIF_FUNCNAME_ARGS_NAMES        = 0x00200000,
        FIF_FUNCNAME_ARGS_VALUES    = 0x00400000,

        FIF_FUNCNAME_ARGS_ALL       = 0x00700000,

        // Argument formatting (in m_bstrArgs)
        FIF_ARGS_TYPES              = 0x01000000,
        FIF_ARGS_NAMES              = 0x02000000,
        FIF_ARGS_VALUES             = 0x04000000,

        FIF_ARGS_ALL                = 0x07000000,

        // If a client wants to be able to manipulate each arg separately,
        // set the FIF_ARGS_NOFORMAT and each FIF_ARGS_* flag will cause a
        // null-termianted string to be added to m_bstrArgs.
        // m_bstrArgs will then contain a series of null-terminated strings--
        // one string per flag per arg. For example, if the name and value
        // flag are set and there are two args x and y, the string would be
        // "x<null char>3<null char>y<null char>4<null char>".
        FIF_ARGS_NOFORMAT           = 0x08000000,

        // For argument values, set FIF_ARGS_NO_FUNC_EVAL to turn off
        // function (property) evaluation when retrieving argument values.
        // This applies to whether arguments are being formatted in
        // the function name string or in m_bstrArgs.  See also 
        // FIF_ARGS_NO_TOSTRING.
        FIF_ARGS_NO_FUNC_EVAL        = 0x10000000,

        // Have the engine to filter user code frames. (Perf)
        FIF_FILTER_NON_USER_CODE    = 0x20000000,

        // Do not allow ToString() func-evals when returning function arguments.
        FIF_ARGS_NO_TOSTRING        = 0x40000000,

    // frame info should be gotten from the hosted app-domain
    // rather than the hosting process.
    FIF_DESIGN_TIME_EXPR_EVAL   = 0x80000000,

        // Include all frames
        FIF_FILTER_INCLUDE_ALL     = 0x00080000
}
alias DWORD enum_FRAMEINFO_FLAGS;
alias DWORD FRAMEINFO_FLAGS;
enum /+ enum_FRAMEINFO_FLAGS_VALUES+/ : DWORD 
{
        FIFV_ANNOTATEDFRAME = 0x00000001,
        FIFV_NON_USER_CODE  = 0x00000002,
        FIFV_CANINTERCEPT_EXCEPTION = 0x00000004,
        FIFV_FUNCEVALFRAME = 0x00000008,
}
alias DWORD enum_FRAMEINFO_FLAGS_VALUES;
alias DWORD FRAMEINFO_FLAGS_VALUES;
struct tagFRAMEINFO
{
        FRAMEINFO_FLAGS            m_dwValidFields;    // which FRAMEINFO fields were successfully initialized
        BSTR                    m_bstrFuncName;        // function name
        BSTR                    m_bstrReturnType;    // function return type
        BSTR                    m_bstrArgs;            // function arguments (
        BSTR                    m_bstrLanguage;        // language name
        BSTR                    m_bstrModule;        // module name (i.e. "msvcrt.dll" or "Test.class")
        UINT64                    m_addrMin;            // minimum physical stack address
        UINT64                    m_addrMax;            // maximum physical stack address
        IDebugStackFrame2        m_pFrame;            // IDebugStackFrame2 object corresponding to this stack frame
        IDebugModule2            m_pModule;            // Module this frame is in.
        BOOL                    m_fHasDebugInfo;    // TRUE if there is debug information in that frame.
        BOOL                    m_fStaleCode;        // TRUE if frame corresponds to stale code
        DWORD                    m_dwFlags;
}
alias tagFRAMEINFO FRAMEINFO;;

// ------------------------------------------------------------------
// IDebugLogicalThread2
// {95E4AC61-D37E-4fce-B6C6-C05A80AB946A}
// DEFINE_GUID(<<name>>,
// 0x95e4ac61, 0xd37e, 0x4fce, 0xb6, 0xc6, 0xc0, 0x5a, 0x80, 0xab, 0x94, 0x6a);
const GUID IID_IDebugLogicalThread2 = IDebugLogicalThread2.iid;

interface IDebugLogicalThread2 : IUnknown
{
    static const GUID iid = { 0x88d2f75b,0xd329,0x4e03,[ 0x9b,0x75,0x20,0x1f,0x77,0x82,0xd8,0xbd ] };
    HRESULT EnumFrameInfo
    (
        in  FRAMEINFO_FLAGS dwFieldSpec,
        in  UINT nRadix,
        /+[out]+/ IEnumDebugFrameInfo2 * ppEnum
    );
};

// ------------------------------------------------------------------
// IDebugThread3
// {43D24196-0000-467f-8C6B-9C006922D02F}
const GUID IID_IDebugThread3 = IDebugThread3.iid;

interface IDebugThread3 : IDebugThread2
{
    static const GUID iid = { 0x43D24196,0x0000,0x467f,[ 0x8C,0x6B,0x9C,0x00,0x69,0x22,0xD0,0x2F ] };
    // Returns S_OK if there is a current exception, S_FALSE if there isn't.
    HRESULT IsCurrentException();

    // Determines If the leaf frame will remap immeadiately after an apply.
    // It cannot determine if the IP is in a finally clause.  The user
    // must also query IDebugENC2::IsLeafRemapPossible to handle that.
    HRESULT CanRemapLeafFrame();
    
    // Force the leaf frame to remap.  Will only succeed if CanRemapLeafFrame
    // would return S_OK.
    HRESULT RemapLeafFrame();
}; 

// -----------------------------------------------------------------------
// IDebugProperty2 and IDebugReference2 attributes

enum DBG_ATTRIB_NONE =                    0x0000000000000000;
enum DBG_ATTRIB_ALL =                    0xffffffffffffffff;

// Attributes about the object itself

// The reference/property is expandable
enum DBG_ATTRIB_OBJ_IS_EXPANDABLE =        0x0000000000000001;

// This property indicates that an id for this object has been created.
enum DBG_ATTRIB_OBJ_HAS_ID =            0x0000000000000002;
// This property indicates that an id for this object can be created.
enum DBG_ATTRIB_OBJ_CAN_HAVE_ID =            0x0000000000000004;

// Attributes about the value of the object

// The value of this reference/property is read only
enum DBG_ATTRIB_VALUE_READONLY =        0x0000000000000010;
// The value is an error
enum DBG_ATTRIB_VALUE_ERROR =            0x0000000000000020;
// The evaluation caused a side effect
enum DBG_ATTRIB_VALUE_SIDE_EFFECT =        0x0000000000000040;
// This property is really a container of overloads
enum DBG_ATTRIB_OVERLOADED_CONTAINER =    0x0000000000000080;
// This property is a boolean value
enum DBG_ATTRIB_VALUE_BOOLEAN =            0x0000000000000100;
// If DBG_ATTRIB_VALUE_BOOLEAN is set,
// then this flag indicates whether the boolean value is true or false
enum DBG_ATTRIB_VALUE_BOOLEAN_TRUE =    0x0000000000000200;
// The value for this property is invalid (i.e. has no value)
enum DBG_ATTRIB_VALUE_INVALID =            0x0000000000000400;
// The value for this property is NAT (not a thing)
enum DBG_ATTRIB_VALUE_NAT =                0x0000000000000800;
// The value for this property has possibly been autoexpanded
enum DBG_ATTRIB_VALUE_AUTOEXPANDED =    0x0000000000001000;
// This property indicates an evaluation timed-out
enum DBG_ATTRIB_VALUE_TIMEOUT =         0x0000000000002000;
// This property indicates that this property can be represented by a raw string
enum DBG_ATTRIB_VALUE_RAW_STRING =      0x0000000000004000;
// This property indicates that this property has a custom viewer
enum DBG_ATTRIB_VALUE_CUSTOM_VIEWER =   0x0000000000008000;

// Attributes that describe field access control
enum DBG_ATTRIB_ACCESS_NONE =            0x0000000000010000;
enum DBG_ATTRIB_ACCESS_PUBLIC =            0x0000000000020000;
enum DBG_ATTRIB_ACCESS_PRIVATE =        0x0000000000040000;
enum DBG_ATTRIB_ACCESS_PROTECTED =        0x0000000000080000;
enum DBG_ATTRIB_ACCESS_FINAL =            0x0000000000100000;

enum DBG_ATTRIB_ACCESS_ALL =            0x00000000001f0000;

// Attributes that describe storage types
enum DBG_ATTRIB_STORAGE_NONE =            0x0000000001000000;
enum DBG_ATTRIB_STORAGE_GLOBAL =        0x0000000002000000;
enum DBG_ATTRIB_STORAGE_STATIC =        0x0000000004000000;
enum DBG_ATTRIB_STORAGE_REGISTER =        0x0000000008000000;

enum DBG_ATTRIB_STORAGE_ALL =            0x000000000f000000;

// Attributes that describe type modifiers
enum DBG_ATTRIB_TYPE_NONE =                0x0000000100000000;
enum DBG_ATTRIB_TYPE_VIRTUAL =            0x0000000200000000;
enum DBG_ATTRIB_TYPE_CONSTANT =            0x0000000400000000;
enum DBG_ATTRIB_TYPE_SYNCHRONIZED =        0x0000000800000000;
enum DBG_ATTRIB_TYPE_VOLATILE =            0x0000001000000000;

enum DBG_ATTRIB_TYPE_ALL =                0x0000001f00000000;

// Attributes that describe the IDebugProperty2 type
enum DBG_ATTRIB_DATA =                    0x0000010000000000;
enum DBG_ATTRIB_METHOD =                0x0000020000000000;
enum DBG_ATTRIB_PROPERTY =                0x0000040000000000;
enum DBG_ATTRIB_CLASS =                    0x0000080000000000;
enum DBG_ATTRIB_BASECLASS =                0x0000100000000000;
enum DBG_ATTRIB_INTERFACE =                0x0000200000000000;
enum DBG_ATTRIB_INNERCLASS =            0x0000400000000000;
enum DBG_ATTRIB_MOSTDERIVEDCLASS =        0x0000800000000000;

enum DBG_ATTRIB_CHILD_ALL =                0x0000ff0000000000;

enum DBG_ATTRIB_MULTI_CUSTOM_VIEWERS =  0x0001000000000000;
enum DBG_ATTRIB_EVENT =                 0x0002000000000000;

alias UINT64 DBG_ATTRIB_FLAGS;

// -----------------------------------------------------------------------
// IDebugProperty2

enum /+ enum_DEBUGPROP_INFO_FLAGS+/ : DWORD 
{
    DEBUGPROP_INFO_FULLNAME                    = 0x00000001,
    DEBUGPROP_INFO_NAME                        = 0x00000002,
    DEBUGPROP_INFO_TYPE                        = 0x00000004,
    DEBUGPROP_INFO_VALUE                    = 0x00000008,
    DEBUGPROP_INFO_ATTRIB                    = 0x00000010,
    DEBUGPROP_INFO_PROP                        = 0x00000020,

    DEBUGPROP_INFO_VALUE_AUTOEXPAND            = 0x00010000,
    DEBUGPROP_INFO_NOFUNCEVAL                = 0x00020000,   // Tell EE not to perform ANY type of func-eval.
    DEBUGPROP_INFO_VALUE_RAW                = 0x00040000,   // Tell EE not to return any beautified values or members.
    DEBUGPROP_INFO_VALUE_NO_TOSTRING        = 0x00080000,   // Tell EE not to return any special synthesized values (ToString() for instance).
    DEBUGPROP_INFO_NO_NONPUBLIC_MEMBERS        = 0x00100000,   // Tell EE to return non-public members for non-user objects.

    DEBUGPROP_INFO_NONE                    = 0x00000000,
    DEBUGPROP_INFO_STANDARD                = DEBUGPROP_INFO_ATTRIB | DEBUGPROP_INFO_NAME | DEBUGPROP_INFO_TYPE | DEBUGPROP_INFO_VALUE,
    DEBUGPROP_INFO_ALL                    = 0xffffffff
}
alias DWORD enum_DEBUGPROP_INFO_FLAGS;
alias DWORD DEBUGPROP_INFO_FLAGS;

struct tagDEBUG_PROPERTY_INFO
{
    DEBUGPROP_INFO_FLAGS    dwFields;
    BSTR                    bstrFullName;
    BSTR                    bstrName;
    BSTR                    bstrType;
    BSTR                    bstrValue;
    IDebugProperty2        pProperty;
    DBG_ATTRIB_FLAGS        dwAttrib;
}
alias tagDEBUG_PROPERTY_INFO DEBUG_PROPERTY_INFO;

struct tagDEBUG_CUSTOM_VIEWER
{
    DWORD dwID;                 // An ID to differentiate multiple viewers implemented by one guid.
    BSTR bstrMenuName;          // The text that will appear in the drop-down menu.
    BSTR bstrDescription;       // A description of the Custom Viewer (NULL if not used)
    GUID guidLang;              // Language of the providing EE
    GUID guidVendor;            // Vendor of the providing EE
    BSTR bstrMetric;
}
alias tagDEBUG_CUSTOM_VIEWER DEBUG_CUSTOM_VIEWER;

const GUID IID_IDebugProperty2 = IDebugProperty2.iid;

interface IDebugProperty2 : IUnknown
{
    static const GUID iid = { 0xa7ee3e7e,0x2dd2,0x4ad7,[ 0x96,0x97,0xf4,0xaa,0xe3,0x42,0x77,0x62 ] };
    // Get the DEBUG_PROPERTY_INFO that describes this property
    HRESULT GetPropertyInfo(
        in DEBUGPROP_INFO_FLAGS dwFields,
        in DWORD dwRadix,
        in DWORD dwTimeout,
        /+[ ptr , size_is(dwArgCount), length_is(dwArgCount)]+/ /+[in]+/ IDebugReference2 * rgpArgs,
        in DWORD dwArgCount,
        /+[out]+/ DEBUG_PROPERTY_INFO* pPropertyInfo);

    // Set the value of this property
    HRESULT SetValueAsString(
        in LPCOLESTR pszValue,
        in DWORD dwRadix,
        in DWORD dwTimeout);

    // Set the value of this property
    HRESULT SetValueAsReference(
        /+[ ptr , size_is(dwArgCount), length_is(dwArgCount)]+/ /+[in]+/ IDebugReference2 * rgpArgs,
        in DWORD dwArgCount,
        /+[in]+/ IDebugReference2 pValue,
        in DWORD dwTimeout);

    // Enum the children of this property
    HRESULT EnumChildren(
        in DEBUGPROP_INFO_FLAGS dwFields,
        in DWORD dwRadix,
        in GUID* guidFilter,
        in DBG_ATTRIB_FLAGS dwAttribFilter,
        /+[ ptr]+/ in LPCOLESTR pszNameFilter,
        in DWORD dwTimeout,
        /+[out]+/ IEnumDebugPropertyInfo2 * ppEnum);

    // Get the parent of this property
    HRESULT GetParent(
        /+[out]+/ IDebugProperty2 * ppParent);

    // Get the property that describes the derived most property of this property
    HRESULT GetDerivedMostProperty(
        /+[out]+/ IDebugProperty2 * ppDerivedMost);

    // Get the memory bytes that contains this property
    HRESULT GetMemoryBytes(
        /+[out]+/ IDebugMemoryBytes2 * ppMemoryBytes);

    // Get a memory context for this property within the memory bytes returned by GetMemoryBytes
    HRESULT GetMemoryContext(
        /+[out]+/ IDebugMemoryContext2 * ppMemory);

    // Get the size (in bytes) of this property
    HRESULT GetSize(
        /+[out]+/ DWORD* pdwSize);

    // Get a reference for this property
    HRESULT GetReference(
        /+[out]+/ IDebugReference2 * ppReference);

    // Get extended info for this property
    HRESULT GetExtendedInfo(
        in GUID* guidExtendedInfo,
        /+[out]+/ VARIANT* pExtendedInfo);
};

// Note: This interface is new in 8.0. It is a way for the shell to tell the SDM
// that an IDebugProperty is no longer used. This isn't important for an appartment
// model shell, but is important for a free threaded shell
// #pragma warning(push)
// #pragma warning(disable:28718)
const GUID IID_IDebugSessionProperty2 = IDebugSessionProperty2.iid;

interface IDebugSessionProperty2 : IDebugProperty3
{
    static const GUID iid = { 0x72ff2712,0x0bc3,0x4308,[ 0xa9,0x9d,0x26,0xac,0x7e,0xc6,0x8c,0x5f ] };
    HRESULT Close();
    HRESULT GetThread(
        /+[out]+/ IDebugThread3 * ppThread);
};
// #pragma warning(pop)

// Note: this interface is new in 8.0. Debug engines should implement this interface
// if they need WatchForExpressionEval called in order to destroy an IDebugProperty
const GUID IID_IDebugPropertyClose2 = IDebugPropertyClose2.iid;

interface IDebugPropertyClose2 : IDebugProperty2
{
    static const GUID iid = { 0x852c7d42,0x794f,0x43cd,[ 0xa1,0x8f,0xcd,0x40,0xe8,0x3e,0x67,0xcd ] };
    HRESULT Close();
};

// #pragma warning(push)
// #pragma warning(disable:28718)
const GUID IID_IDebugProperty3 = IDebugProperty3.iid;

interface IDebugProperty3 : IDebugProperty2
{
    static const GUID iid = { 0x94E1E004,0x0672,0x423d,[ 0xAD,0x62,0x78,0x78,0x3D,0xEF,0x1E,0x76 ] };
    // How long is the underlying string (in chars)? (excludes terminating byte)
    HRESULT GetStringCharLength( /+[out]+/ ULONG *pLen );

    // Get the actual string contents (excludes terminating byte)
    HRESULT GetStringChars(
        in ULONG buflen,
        /+[out, size_is(buflen), length_is(*pceltFetched)]+/ WCHAR *rgString,
        /+[out]+/ ULONG *pceltFetched
    );

    // created the id for this object
    HRESULT CreateObjectID();

    // destroy the id for this object
    HRESULT DestroyObjectID();

    // Support for custom visualizers
    HRESULT GetCustomViewerCount(/+[out]+/ ULONG* pcelt);
    HRESULT GetCustomViewerList(in ULONG celtSkip, in ULONG celtRequested, 
        /+[out, size_is(celtRequested),length_is(*pceltFetched)]+/ DEBUG_CUSTOM_VIEWER* rgViewers, 
        /+[out]+/ ULONG* pceltFetched);

    // Set the value of this property
    HRESULT SetValueAsStringWithError(
        in LPCOLESTR pszValue,
        in DWORD dwRadix,
        in DWORD dwTimeout,
        /+[out]+/ BSTR * errorString);
};
// #pragma warning(pop)

// Note: This interface is new in 8.0.  It is a way for the shell to be able to
//       show a grid of data from an expression.
const GUID IID_IDebugDataGrid = IDebugDataGrid.iid;

interface IDebugDataGrid : IUnknown
{
    static const GUID iid = { 0x411F3E08,0xE6B1,0x4789,[ 0xAB,0x29,0x75,0x5C,0x52,0xE5,0x2A,0xC4 ] };
    HRESULT GetGridInfo(
        /+[out]+/ ULONG *pX,
        /+[out]+/ ULONG *pY,
        /+[out]+/ BSTR *bpstrTitle
        );

    HRESULT GetGridPropertyInfo(
        ULONG x,
        ULONG y,
        ULONG celtX,
        ULONG celtY,
        ULONG celtXtimesY,
        DEBUGPROP_INFO_FLAGS dwFields,
        DWORD dwRadix,
        /+[out, size_is(celtXtimesY), length_is(*pceltFetched)]+/ DEBUG_PROPERTY_INFO* rgelt,
        /+[out]+/ ULONG* pceltFetched
        );
};

// Note: This interface is new in 8.0. Only the SDM needs to implement it
// It is for the shell to ensure extended property evaluation works correctly
// when multiple engines are involved, and to extract a raw interface from a wrapped one
const GUID IID_IDebugPropertySafetyWrapper = IDebugPropertySafetyWrapper.iid;

interface IDebugPropertySafetyWrapper : IUnknown
{
    static const GUID iid = { 0x7031886B,0x61D2,0x4cb5,[ 0xB9,0x09,0x00,0x38,0x60,0x90,0x73,0x3B ] };
    HRESULT BeforePropertyCall();
    HRESULT AfterPropertyCall();
    HRESULT GetRawProperty( /+[out]+/ IDebugProperty3 * ppProperty);
}

// -----------------------------------------------------------------------
// IDebugReference2

enum /+ enum_REFERENCE_TYPE+/ : DWORD 
{
    // Weak reference
    REF_TYPE_WEAK                        = 0x0001,
    // Strong reference
    REF_TYPE_STRONG                        = 0x0002,
}
alias DWORD enum_REFERENCE_TYPE;
alias DWORD REFERENCE_TYPE;

enum /+ enum_DEBUGREF_INFO_FLAGS+/ : DWORD 
{
    DEBUGREF_INFO_NAME                    = 0x00000001,
    DEBUGREF_INFO_TYPE                    = 0x00000002,
    DEBUGREF_INFO_VALUE                    = 0x00000004,
    DEBUGREF_INFO_ATTRIB                = 0x00000008,
    DEBUGREF_INFO_REFTYPE                = 0x00000010,
    DEBUGREF_INFO_REF                    = 0x00000020,

    DEBUGREF_INFO_VALUE_AUTOEXPAND        = 0x00010000,

    DEBUGREF_INFO_NONE                    = 0x00000000,
    DEBUGREF_INFO_ALL                    = 0xffffffff
}
alias DWORD enum_DEBUGREF_INFO_FLAGS;
alias DWORD DEBUGREF_INFO_FLAGS;

struct tagDEBUG_REFERENCE_INFO
{
    DEBUGREF_INFO_FLAGS        dwFields;
    BSTR                    bstrName;
    BSTR                    bstrType;
    BSTR                    bstrValue;
    DBG_ATTRIB_FLAGS        dwAttrib;
    REFERENCE_TYPE            dwRefType;
    IDebugReference2        pReference;
}
alias tagDEBUG_REFERENCE_INFO DEBUG_REFERENCE_INFO;

const GUID IID_IDebugReference2 = IDebugReference2.iid;

interface IDebugReference2 : IUnknown
{
    static const GUID iid = { 0x10b793ac,0x0c47,0x4679,[ 0x84,0x54,0xad,0xb3,0x6f,0x29,0xf8,0x02 ] };

    // Get the DEBUG_REFERENCE_INFO that describes this reference
    HRESULT GetReferenceInfo(
        in DEBUGREF_INFO_FLAGS dwFields,
        in DWORD dwRadix,
        in DWORD dwTimeout,
        /+[ size_is (dwArgCount), length_is(dwArgCount)]+/ /+[in]+/ IDebugReference2 * rgpArgs,
        in DWORD dwArgCount,
        /+[out]+/ DEBUG_REFERENCE_INFO* pReferenceInfo);

    // Set the value of this reference
    HRESULT SetValueAsString(
        in LPCOLESTR pszValue,
        in DWORD dwRadix,
        in DWORD dwTimeout);

    // Set the value of this reference
    HRESULT SetValueAsReference(
        /+[ size_is (dwArgCount), length_is(dwArgCount)]+/ /+[in]+/ IDebugReference2 * rgpArgs,
        in DWORD dwArgCount,
        /+[in]+/ IDebugReference2 pValue,
        in DWORD dwTimeout);

    // Enum the children of this reference
    HRESULT EnumChildren(
        in DEBUGREF_INFO_FLAGS dwFields,
        in DWORD dwRadix,
        in DBG_ATTRIB_FLAGS dwAttribFilter,
        /+[ ptr]+/ in LPCOLESTR pszNameFilter,
        in DWORD dwTimeout,
        /+[out]+/ IEnumDebugReferenceInfo2 * ppEnum);

    // Get the parent of this reference
    HRESULT GetParent(
        /+[out]+/ IDebugReference2 * ppParent);

    // Get the reference that describes the derived most reference of this reference
    HRESULT GetDerivedMostReference(
        /+[out]+/ IDebugReference2 * ppDerivedMost);

    // Get the memory bytes that contains this reference
    HRESULT GetMemoryBytes(
        /+[out]+/ IDebugMemoryBytes2 * ppMemoryBytes);

    // Get a memory context for this reference within the memory bytes returned by GetMemoryBytes
    HRESULT GetMemoryContext(
        /+[out]+/ IDebugMemoryContext2 * ppMemory);

    // Get the size (in bytes) of this reference
    HRESULT GetSize(
        /+[out]+/ DWORD* pdwSize);

    // Set the reference type (weak or strong)
    HRESULT SetReferenceType(
        in REFERENCE_TYPE dwRefType);

    // Compare this reference with the one given in the matter given
    // result = this cwCompare pReference
    HRESULT Compare(
        in REFERENCE_COMPARE dwCompare,
        /+[in]+/ IDebugReference2 pReference);
}
enum /+ enum_REFERENCE_COMPARE+/ : DWORD 
{
        REF_COMPARE_EQUAL                = 0x0001,
        REF_COMPARE_LESS_THAN            = 0x0002,
        REF_COMPARE_GREATER_THAN        = 0x0003,
}
alias DWORD enum_REFERENCE_COMPARE;
alias DWORD REFERENCE_COMPARE;;

// ------------------------------------------------------------------
// IDebugStackFrame2
const GUID IID_IDebugStackFrame2 = IDebugStackFrame2.iid;

interface IDebugStackFrame2 : IUnknown
{
    static const GUID iid = { 0x1412926f,0x5dd6,0x4e58,[ 0xb6,0x48,0xe1,0xc6,0x3e,0x01,0x3d,0x51 ] };
    HRESULT GetCodeContext(
        /+[out]+/ IDebugCodeContext2 * ppCodeCxt);

    HRESULT GetDocumentContext(
        /+[out]+/ IDebugDocumentContext2 * ppCxt);

    HRESULT GetName(
        /+[out]+/ BSTR* pbstrName);

    HRESULT GetInfo(
        in  FRAMEINFO_FLAGS dwFieldSpec,
        in  UINT nRadix,
        /+[out]+/ FRAMEINFO* pFrameInfo);

    // Returns a machine dependent representation of the range of physical addresses
    // associated with this stack frame. This is used by the process debug manager to sort
    // the stack frames from multiple script engines. By convention, stacks grow down and,
    // as such, on architectures where stacks grow up the addresses should be
    // twos-complemented.
    // NOTE: This implementation will not work for cross-process or cross-machine stacks
    HRESULT GetPhysicalStackRange(
        /+[out]+/ UINT64* paddrMin,
        /+[out]+/ UINT64* paddrMax);

    HRESULT GetExpressionContext(
        /+[out]+/ IDebugExpressionContext2 * ppExprCxt);

    HRESULT GetLanguageInfo(
        /+[in, out, ptr]+/ BSTR* pbstrLanguage,
        /+[in, out, ptr]+/ GUID* pguidLanguage);

    HRESULT GetDebugProperty(
        /+[out]+/ IDebugProperty2 * ppProperty);

    // PERF API - Get the count of locals as well as the enumerator
    // This API may not be supported by all LEs, so if it fails, use the generic
    // approach through GetDebugProperty.  However, if this API is supported it
    // may save a few cross-process calls
    HRESULT EnumProperties(
        in DEBUGPROP_INFO_FLAGS dwFields,
        in UINT nRadix,
        in GUID* guidFilter,
        in DWORD dwTimeout,
        /+[out]+/ ULONG* pcelt,
        /+[out]+/ IEnumDebugPropertyInfo2 * ppEnum);

    HRESULT GetThread(
        /+[out]+/ IDebugThread2 * ppThread);
};

// ------------------------------------------------------------------
// IDebugStackFrame3
// An extension of IDebugStackFrame2 for new debugger features
// supported in VS version 8.
const GUID IID_IDebugStackFrame3 = IDebugStackFrame3.iid;

interface IDebugStackFrame3 : IDebugStackFrame2
{
    static const GUID iid = { 0x60DE844B,0x38B1,0x4d87,[ 0xAF,0xE1,0x8C,0xF4,0x96,0x77,0xD3,0xB0 ] };

    // Install a temporary exception handler at this
    // frame that will "handle" the current
    // exception on the next call to Execute, Continue,
    // or Step. Specific behavior varies by the debug engine/
    // platform/runtime environment. Once the exception
    // is "handled" by the temporary handler, an
    // IDebugInterceptExceptionCompleteEvent2 will be sent.
    // This function is not supported by all debug engines.
    HRESULT InterceptCurrentException(
        in INTERCEPT_EXCEPTION_ACTION dwFlags,
        /+[out]+/ UINT64* pqwCookie);

    // Returns the code context representing the location
    // if a stack unwind is done. Note that this doesn't imply 
    // that a stack unwind can be done to this frame.
    // This method isn't supported by all engines currently.
    HRESULT GetUnwindCodeContext(
        /+[out]+/ IDebugCodeContext2 *ppCodeContext);
}
enum /+ enum_INTERCEPT_EXCEPTION_ACTION+/ : DWORD 
{
        IEA_INTERCEPT            = 0x0001,
        // Cancelling an intercept is not supported in VS8
        IEA_CANCEL_INTERCEPT    = 0x0000,
}
alias DWORD enum_INTERCEPT_EXCEPTION_ACTION;
alias DWORD INTERCEPT_EXCEPTION_ACTION;;

// ------------------------------------------------------------------
// IDebugMemoryContext2

const GUID IID_IDebugMemoryContext2 = IDebugMemoryContext2.iid;

interface IDebugMemoryContext2 : IUnknown
{
    static const GUID iid = { 0x1ab276dd,0xf27b,0x4445,[ 0x82,0x5d,0x5d,0xf0,0xb4,0xa0,0x4a,0x3a ] };

    HRESULT GetName(
        /+[out]+/ BSTR* pbstrName);

    HRESULT GetInfo(
        in CONTEXT_INFO_FIELDS dwFields,
        /+[out]+/ CONTEXT_INFO* pInfo);

    HRESULT Add(
        in UINT64 dwCount,
        /+[out]+/ IDebugMemoryContext2 * ppMemCxt);

    HRESULT Subtract(
        in UINT64 dwCount,
        /+[out]+/ IDebugMemoryContext2 * ppMemCxt);

    HRESULT Compare(
        in CONTEXT_COMPARE compare,
        /+[ size_is (dwMemoryContextSetLen), length_is(dwMemoryContextSetLen)]+/ /+[in]+/ IDebugMemoryContext2 * rgpMemoryContextSet,
        in DWORD dwMemoryContextSetLen,
        /+[out]+/ DWORD* pdwMemoryContext);
}
enum /+ enum_CONTEXT_COMPARE+/ : DWORD 
{
        CONTEXT_EQUAL                    = 0x0001,
        CONTEXT_LESS_THAN                = 0x0002,
        CONTEXT_GREATER_THAN            = 0x0003,
        CONTEXT_LESS_THAN_OR_EQUAL        = 0x0004,
        CONTEXT_GREATER_THAN_OR_EQUAL    = 0x0005,
        CONTEXT_SAME_SCOPE                = 0x0006,
        CONTEXT_SAME_FUNCTION            = 0x0007,
        CONTEXT_SAME_MODULE                = 0x0008,
        CONTEXT_SAME_PROCESS            = 0x0009,
}
alias DWORD enum_CONTEXT_COMPARE;
alias DWORD CONTEXT_COMPARE;
enum /+ enum_CONTEXT_INFO_FIELDS+/ : DWORD 
{
        CIF_MODULEURL        = 0x00000001,
        CIF_FUNCTION        = 0x00000002,
        CIF_FUNCTIONOFFSET    = 0x00000004,
        CIF_ADDRESS            = 0x00000008,
        CIF_ADDRESSOFFSET    = 0x00000010,
        CIF_ADDRESSABSOLUTE = 0x00000020,
        
        CIF_ALLFIELDS        = 0x0000003f,
}
alias DWORD enum_CONTEXT_INFO_FIELDS;
alias DWORD CONTEXT_INFO_FIELDS;
struct _tagCONTEXT_INFO
{
        CONTEXT_INFO_FIELDS dwFields;
        BSTR bstrModuleUrl;
        BSTR bstrFunction;
        TEXT_POSITION posFunctionOffset;
        BSTR bstrAddress;
        BSTR bstrAddressOffset;
        BSTR bstrAddressAbsolute;
}
alias _tagCONTEXT_INFO CONTEXT_INFO;;

// ------------------------------------------------------------------
// IDebugCodeContext2
const GUID IID_IDebugCodeContext2 = IDebugCodeContext2.iid;

interface IDebugCodeContext2 : IDebugMemoryContext2
{
    static const GUID iid = { 0xac17b76b,0x2b09,0x419a,[ 0xad,0x5f,0x7d,0x74,0x02,0xda,0x88,0x75 ] };
    HRESULT GetDocumentContext(
        /+[out]+/ IDebugDocumentContext2 *ppSrcCxt);

    HRESULT GetLanguageInfo(
        /+[in, out, ptr]+/ BSTR* pbstrLanguage,
        /+[in, out, ptr]+/ GUID* pguidLanguage);
};

// ------------------------------------------------------------------
// IDebugCodeContext3
//
// QI from IDebugCodeContext2
const GUID IID_IDebugCodeContext3 = IDebugCodeContext3.iid;

interface IDebugCodeContext3 : IDebugCodeContext2
{
    static const GUID iid = { 0x17c106b9,0x0925,0x42f5,[ 0xae,0x32,0x1f,0xc0,0x19,0x64,0x9c,0x10 ] };
    HRESULT GetModule(
        /+[out]+/ IDebugModule2 * ppModule);

    HRESULT GetProcess(
        /+[out]+/ IDebugProcess2 * ppProcess);
};

// ------------------------------------------------------------------
// IDebugMemoryBytes2

const GUID IID_IDebugMemoryBytes2 = IDebugMemoryBytes2.iid;

interface IDebugMemoryBytes2 : IUnknown
{
    static const GUID iid = { 0x925837d1,0x3aa1,0x451a,[ 0xb7,0xfe,0xcc,0x04,0xbb,0x42,0xcf,0xb8 ] };
    HRESULT ReadAt(
        /+[in]+/ IDebugMemoryContext2 pStartContext,
        in DWORD dwCount,
        /+[out, size_is(dwCount), length_is(*pdwRead)]+/ BYTE* rgbMemory,
        /+[out]+/ DWORD* pdwRead,
        /+[in, out, ptr]+/ DWORD* pdwUnreadable);

    HRESULT WriteAt(
        /+[in]+/ IDebugMemoryContext2 pStartContext,
        in DWORD dwCount,
        /+[ size_is (dwCount), length_is(dwCount)]+/ in BYTE* rgbMemory);

    HRESULT GetSize(
        /+[out]+/ UINT64* pqwSize);
};

// ------------------------------------------------------------------
// IDebugDisassemblyStream2

const GUID IID_IDebugDisassemblyStream2 = IDebugDisassemblyStream2.iid;

interface IDebugDisassemblyStream2 : IUnknown
{
    static const GUID iid = { 0xe5b017fe,0xdfb0,0x411c,[ 0x82,0x66,0x7c,0x64,0xd6,0xf5,0x19,0xf8 ] };

    HRESULT Read(
        // Set dwInstruction to 0 for !DSS_HUGE address spaces to read the entire address space
        in DWORD dwInstructions,
        in DISASSEMBLY_STREAM_FIELDS dwFields,
        /+[out]+/ DWORD* pdwInstructionsRead,
        /+[out, size_is(dwInstructions), length_is(*pdwInstructionsRead)]+/ DisassemblyData* prgDisassembly);

    HRESULT Seek(
        in SEEK_START dwSeekStart,
        /+[in]+/ IDebugCodeContext2 pCodeContext,
        in UINT64 uCodeLocationId,
        in INT64 iInstructions);

    // If the code context is outside the scope of code contexts which can be
    // disassembled by this stream, but is still a valid code context. then
    // *puCodeLocationId should be zero, and the return value is E_CODE_CONTEXT_OUT_OF_SCOPE
    HRESULT GetCodeLocationId(
        /+[in]+/ IDebugCodeContext2 pCodeContext,
        /+[out]+/ UINT64* puCodeLocationId);

    HRESULT GetCodeContext(
        in UINT64 uCodeLocationId,
        /+[out]+/ IDebugCodeContext2 * ppCodeContext);

    HRESULT GetCurrentLocation(
        /+[out]+/ UINT64* puCodeLocationId);        

    // implemented by engines that have text documents, but where bstrDocumentUrl
    // can not be passed as a filename
    HRESULT GetDocument(
        in BSTR bstrDocumentUrl,
        /+[out]+/ IDebugDocument2 * ppDocument);

    HRESULT GetScope(
        /+[out]+/ DISASSEMBLY_STREAM_SCOPE* pdwScope);

    HRESULT GetSize(
        /+[out]+/ UINT64 *pnSize);
}
enum /+ enum_DISASSEMBLY_STREAM_FIELDS+/ : DWORD 
{
        DSF_ADDRESS             = 0x00000001,
        DSF_ADDRESSOFFSET       = 0x00000002,
        DSF_CODEBYTES           = 0x00000004,
        DSF_OPCODE              = 0x00000008,
        DSF_OPERANDS            = 0x00000010,
        DSF_SYMBOL              = 0x00000020,
        DSF_CODELOCATIONID      = 0x00000040,
        DSF_POSITION            = 0x00000080,
        DSF_DOCUMENTURL         = 0x00000100,
        DSF_BYTEOFFSET          = 0x00000200,
        DSF_FLAGS               = 0x00000400,

        // Use DSF_OPERANDS_SYMBOLS to include symbol names in the bstrOperands field
        DSF_OPERANDS_SYMBOLS    = 0x00010000,

        DSF_ALL                 = 0x000107ff,
}
alias DWORD enum_DISASSEMBLY_STREAM_FIELDS;
alias DWORD DISASSEMBLY_STREAM_FIELDS;
enum /+ enum_DISASSEMBLY_FLAGS+/ : DWORD 
{
        // Indicates this instruction is in a different document than the previous one
        DF_DOCUMENTCHANGE               = 0x00000001,
        // Indicates this instruction will not be exuecuted
        DF_DISABLED                     = 0x00000002,
        // Indicates this instruction is one of the next instructions to be executed
        // (there may be more than one)
        DF_INSTRUCTION_ACTIVE           = 0x00000004,
        // Indicates this instruction is really data (not code)
        DF_DATA                         = 0x00000008,
        // Indicates this instruction has source
        DF_HASSOURCE                    = 0x00000010,
        // Indicates that bstrDocumentUrl contains checksum data
        DF_DOCUMENT_CHECKSUM            = 0x00000020
}
alias DWORD enum_DISASSEMBLY_FLAGS;
alias DWORD DISASSEMBLY_FLAGS;
struct tagDisassemblyData
{
        // Indicates which fields are valid
        DISASSEMBLY_STREAM_FIELDS dwFields;
        // The address for this instruction
        BSTR bstrAddress;
        // The address as an offset from some starting point (usually function)
        BSTR bstrAddressOffset;
        // The code bytes for this instruction
        BSTR bstrCodeBytes;
        // The opcode for this instruction
        BSTR bstrOpcode;
        // The operands for this instruction
        BSTR bstrOperands;
        // The symbol name, if any, associated with this address (public symbol, label, etc.)
        BSTR bstrSymbol;
        // Code location identifier (uCodeLocationId) for this line of disasm.
        // They have these properties.
        // 1. Unique within the disasm stream
        // 2. Ordered in the same way as addresses (iff DisasmLine1.CodeContext.Address >
        //    DisasmLine2.CodeContext.Address then DisasmLine1.uCodeLocationId >
        //    DisasmLine2.uCodeLocationId)
        // 3. As a consequense of #2, IDs should always increase as one go down the DisasmData array
        UINT64 uCodeLocationId;
        TEXT_POSITION posBeg;
        TEXT_POSITION posEnd;
        // For text documents that can be repesented as filenames:
        //    bstrDocumentUrl is filled in with the file://filename where the source can be found.
        // For text documents that cannot be repesented as filenames:
        //    bstrDocumentUrl is a unique identifier for the document. The debug engine
        //    must implement 'IDebugDisassemblyStream2::GetDocument'
        // For non-text documents:
        //    bstrDocumentUrl should be left as NULL. A doc context can be obtained from the code
        //    context
        // For Both:
        //    Note that if bstrDocumentUrl is the same as the bstrDocumentUrl in the previous
        //    DisassemblyData array element, then bstrDocumentUrl should be NULL, otherwise,
        //    bstrDocumentUrl should not be NULL (if it is requested) and DF_DOCUMENTCHANGE should be set
        //
        // If the DF_DOCUMENT_CHECKSUM flag is set, this indicates that the document checksum is stored
        // in bstrDocumentUrl after the NULL as a guid indicating the checksum algorithm, 
        // followed by a DWORD indicating the number of bytes of checksum data, 
        // followed by the array of bytes denoting the checksum value.
        BSTR bstrDocumentUrl;
        // The number of bytes this instruction is from the beginning of the line
        DWORD dwByteOffset;
        // Flags
        DISASSEMBLY_FLAGS dwFlags;
}
alias tagDisassemblyData DisassemblyData;
enum /+ enum_SEEK_START+/ : DWORD 
{
        SEEK_START_BEGIN        = 0x0001,
        SEEK_START_END          = 0x0002,
        SEEK_START_CURRENT      = 0x0003,
        SEEK_START_CODECONTEXT  = 0x0004,
                SEEK_START_CODELOCID    = 0x0005
}
alias DWORD enum_SEEK_START;
alias DWORD SEEK_START;;

// ------------------------------------------------------------------
// IDebugDocumentContext2
const GUID IID_IDebugDocumentContext2 = IDebugDocumentContext2.iid;

interface IDebugDocumentContext2 : IUnknown
{
    static const GUID iid = { 0x931516ad,0xb600,0x419c,[ 0x88,0xfc,0xdc,0xf5,0x18,0x3b,0x5f,0xa9 ] };

    HRESULT GetDocument(
        /+[out]+/ IDebugDocument2 *ppDocument);

    HRESULT GetName(
        in GETNAME_TYPE gnType,
        /+[out]+/ BSTR *pbstrFileName);

    HRESULT EnumCodeContexts(
        /+[out]+/ IEnumDebugCodeContexts2 *ppEnumCodeCxts);

    HRESULT GetLanguageInfo(
        /+[in, out, ptr]+/ BSTR* pbstrLanguage,
        /+[in, out, ptr]+/ GUID* pguidLanguage);

    HRESULT GetStatementRange(
        /+[in, out, ptr]+/ TEXT_POSITION* pBegPosition,
        /+[in, out, ptr]+/ TEXT_POSITION* pEndPosition);

    HRESULT GetSourceRange(
        /+[in, out, ptr]+/ TEXT_POSITION* pBegPosition,
        /+[in, out, ptr]+/ TEXT_POSITION* pEndPosition);

    HRESULT Compare(
        in DOCCONTEXT_COMPARE compare,
        /+[ size_is (dwDocContextSetLen), length_is(dwDocContextSetLen)]+/ /+[in]+/ IDebugDocumentContext2 * rgpDocContextSet,
        in DWORD dwDocContextSetLen,
        /+[out]+/ DWORD* pdwDocContext);

    HRESULT Seek(
        in int nCount,
        /+[out]+/ IDebugDocumentContext2 * ppDocContext);
}
enum /+ enum_DOCCONTEXT_COMPARE+/ : DWORD 
{
        DOCCONTEXT_EQUAL            = 0x0001,
        DOCCONTEXT_LESS_THAN        = 0x0002,
        DOCCONTEXT_GREATER_THAN        = 0x0003,
        DOCCONTEXT_SAME_DOCUMENT    = 0x0004,
}
alias DWORD enum_DOCCONTEXT_COMPARE;
alias DWORD DOCCONTEXT_COMPARE;;

// ------------------------------------------------------------------
// IDebugDocumentChecksum2
// Get this via QI from an IDebugDocumentContext2.
//
const GUID IID_IDebugDocumentChecksum2 = IDebugDocumentChecksum2.iid;

interface IDebugDocumentChecksum2 : IUnknown
{
    static const GUID iid = { 0xc1c74db7,0xa3a7,0x40a2,[ 0xa2,0x79,0xa6,0x3b,0xa7,0x56,0xb8,0xb0 ] };
    HRESULT GetChecksumAndAlgorithmId(
        /+[out]+/ GUID* pRetVal,
        in ULONG cMaxBytes,
        /+[out, length_is(*pcNumBytes), size_is(cMaxBytes)]+/ BYTE* pChecksum,
        /+[out]+/ ULONG* pcNumBytes
        );
};

// ------------------------------------------------------------------
// IDebugENCDocumentContextUpdate
//
// Get this via QI from an IDebugDocumentContext2.
const GUID IID_IDebugENCDocumentContextUpdate = IDebugENCDocumentContextUpdate.iid;

interface IDebugENCDocumentContextUpdate : IUnknown
{
    static const GUID iid = { 0xF5637291,0xD779,0x4580,[ 0xA8,0x2C,0x0D,0x52,0x3E,0x7F,0xDC,0xF0 ] };
    HRESULT UpdateDocumentContext(
        /+[in]+/ IDebugCodeContext2 pContext,
        /+[in]+/ IDebugDocumentContext2 pDocContext);

    HRESULT UpdateStatementPosition(
        in TEXT_POSITION posBegStatement,
        in TEXT_POSITION posEndStatement);
}

// ------------------------------------------------------------------
// IDebugExpressionContext2
const GUID IID_IDebugExpressionContext2 = IDebugExpressionContext2.iid;

interface IDebugExpressionContext2 : IUnknown
{
    static const GUID iid = { 0x37a44580,0xd5fc,0x473e,[ 0xa0,0x48,0x21,0x70,0x2e,0xbf,0xc4,0x66 ] };

    // Get the name of the expression context. The name is the description
    // of this expression context. It is usually something that can be parsed
    // by an expression evaluator that refers to this exact expression context.
    // For C++, the name is "{ function-name, source-file-name, module-file-name }"
    HRESULT GetName(
        /+[out]+/ BSTR* pbstrName);

    HRESULT ParseText(
        in LPCOLESTR pszCode,
        in PARSEFLAGS dwFlags,
        in UINT nRadix,
        /+[out]+/ IDebugExpression2 * ppExpr,
        /+[out]+/ BSTR* pbstrError,
        /+[out]+/ UINT* pichError);
}
enum /+ enum_PARSEFLAGS+/ : DWORD 
{
        // the expression is an expression (not a statement)
        PARSE_EXPRESSION        = 0x0001,
        // the expression might contain function name/parameter signatures, and
        // the expression is to be parsed [and later evaluated] as an address
        PARSE_FUNCTION_AS_ADDRESS = 0x0002,
        // design-time parsing for design-time expression evaluation
        PARSE_DESIGN_TIME_EXPR_EVAL  = 0x1000
}
alias DWORD enum_PARSEFLAGS;
alias DWORD PARSEFLAGS;;

// ------------------------------------------------------------------
// Breakpoint types

enum /+ enum_BP_TYPE+/ : DWORD 
{
    BPT_NONE                = 0x0000,
    BPT_CODE                = 0x0001,
    BPT_DATA                = 0x0002,
    BPT_SPECIAL                = 0x0003,
}
alias DWORD enum_BP_TYPE;
alias DWORD BP_TYPE;

// ------------------------------------------------------------------
// Breakpoint request stuff

enum /+ enum_BP_LOCATION_TYPE+/ : DWORD 
{
    BPLT_NONE                = 0x00000000,
    BPLT_FILE_LINE            = 0x00010000,
    BPLT_FUNC_OFFSET        = 0x00020000,
    BPLT_CONTEXT            = 0x00030000,
    BPLT_STRING                = 0x00040000,
    BPLT_ADDRESS            = 0x00050000,
    BPLT_RESOLUTION            = 0x00060000,

    BPLT_CODE_FILE_LINE        = BPT_CODE | BPLT_FILE_LINE,
    BPLT_CODE_FUNC_OFFSET    = BPT_CODE | BPLT_FUNC_OFFSET,
    BPLT_CODE_CONTEXT        = BPT_CODE | BPLT_CONTEXT,
    BPLT_CODE_STRING        = BPT_CODE | BPLT_STRING,
    BPLT_CODE_ADDRESS        = BPT_CODE | BPLT_ADDRESS,
    BPLT_DATA_STRING        = BPT_DATA | BPLT_STRING,

    BPLT_TYPE_MASK            = 0x0000FFFF,
    BPLT_LOCATION_TYPE_MASK    = 0xFFFF0000
}
alias DWORD enum_BP_LOCATION_TYPE;
alias DWORD BP_LOCATION_TYPE;

struct _BP_LOCATION_CODE_FILE_LINE
{
    BSTR bstrContext;
    IDebugDocumentPosition2 pDocPos;
}
alias _BP_LOCATION_CODE_FILE_LINE BP_LOCATION_CODE_FILE_LINE;

struct _BP_LOCATION_CODE_FUNC_OFFSET
{
    BSTR bstrContext;
    IDebugFunctionPosition2 pFuncPos;
}
alias _BP_LOCATION_CODE_FUNC_OFFSET BP_LOCATION_CODE_FUNC_OFFSET;

struct _BP_LOCATION_CODE_CONTEXT
{
    IDebugCodeContext2    pCodeContext;
}
alias _BP_LOCATION_CODE_CONTEXT BP_LOCATION_CODE_CONTEXT;

struct _BP_LOCATION_CODE_STRING
{
    BSTR bstrContext;
    BSTR bstrCodeExpr;
}
alias _BP_LOCATION_CODE_STRING BP_LOCATION_CODE_STRING;

struct _BP_LOCATION_CODE_ADDRESS
{
    BSTR bstrContext;
    BSTR bstrModuleUrl;
    BSTR bstrFunction;
    BSTR bstrAddress;
}
alias _BP_LOCATION_CODE_ADDRESS BP_LOCATION_CODE_ADDRESS;

struct _BP_LOCATION_DATA_STRING
{
    IDebugThread2 pThread;
    BSTR bstrContext;
    BSTR bstrDataExpr;
    DWORD dwNumElements;
}
alias _BP_LOCATION_DATA_STRING BP_LOCATION_DATA_STRING;

struct _BP_LOCATION_RESOLUTION
{
    IDebugBreakpointResolution2 pResolution;
}
alias _BP_LOCATION_RESOLUTION BP_LOCATION_RESOLUTION;

union BP_LOCATION /+switch(BP_LOCATION_TYPE bpLocationType) bpLocation +/ {
    /+[case BPLT_CODE_FILE_LINE:]+/
        BP_LOCATION_CODE_FILE_LINE bplocCodeFileLine;

    /+[case BPLT_CODE_FUNC_OFFSET:]+/
        BP_LOCATION_CODE_FUNC_OFFSET bplocCodeFuncOffset;

    /+[case BPLT_CODE_CONTEXT:]+/
        BP_LOCATION_CODE_CONTEXT bplocCodeContext;

    /+[case BPLT_CODE_STRING:]+/
        BP_LOCATION_CODE_STRING bplocCodeString;

    /+[case BPLT_CODE_ADDRESS:]+/
        BP_LOCATION_CODE_ADDRESS bplocCodeAddress;

    /+[case BPLT_DATA_STRING:]+/
        BP_LOCATION_DATA_STRING bplocDataString;

    /+[case BPLT_RESOLUTION:]+/
        BP_LOCATION_RESOLUTION bplocResolution;

    /+[default:]+/
        DWORD unused; };

enum /+ enum_BP_PASSCOUNT_STYLE+/ : DWORD 
{
    BP_PASSCOUNT_NONE                = 0x0000,
    BP_PASSCOUNT_EQUAL                = 0x0001,
    BP_PASSCOUNT_EQUAL_OR_GREATER    = 0x0002,
    BP_PASSCOUNT_MOD                = 0x0003,
}
alias DWORD enum_BP_PASSCOUNT_STYLE;
alias DWORD BP_PASSCOUNT_STYLE;

struct _BP_PASSCOUNT
{
    DWORD dwPassCount;
    BP_PASSCOUNT_STYLE stylePassCount;
}
alias _BP_PASSCOUNT BP_PASSCOUNT;

enum /+ enum_BP_COND_STYLE+/ : DWORD 
{
    BP_COND_NONE                    = 0x0000,
    BP_COND_WHEN_TRUE                = 0x0001,
    BP_COND_WHEN_CHANGED            = 0x0002,
}
alias DWORD enum_BP_COND_STYLE;
alias DWORD BP_COND_STYLE;

struct _BP_CONDITION
{
    IDebugThread2 pThread;
    BP_COND_STYLE styleCondition;
    BSTR bstrContext;
    BSTR bstrCondition;
    UINT nRadix;
}
alias _BP_CONDITION BP_CONDITION;

enum /+ enum_BP_FLAGS+/ : DWORD 
{
    BP_FLAG_NONE                    = 0x0000,
    BP_FLAG_MAP_DOCPOSITION            = 0x0001,

    // BP_FLAG_DONT_STOP is used to indicate the
    // breakpoint should be processed bt the debug engine,
    // but that the debug engine ultimately shouldn't stop
    // there (i.e. an IDebugBreakpointEvent2 should not be 
    // send.  This flag is designed to be used primarily with
    // tracepoints.
    BP_FLAG_DONT_STOP               = 0x0002,
}
alias DWORD enum_BP_FLAGS;
alias DWORD BP_FLAGS;

enum /+ enum_BPREQI_FIELDS+/ : DWORD 
{
    BPREQI_BPLOCATION                = 0x0001,
    BPREQI_LANGUAGE                    = 0x0002,
    BPREQI_PROGRAM                    = 0x0004,
    BPREQI_PROGRAMNAME                = 0x0008,
    BPREQI_THREAD                    = 0x0010,
    BPREQI_THREADNAME                = 0x0020,
    BPREQI_PASSCOUNT                = 0x0040,
    BPREQI_CONDITION                = 0x0080,
    BPREQI_FLAGS                    = 0x0100,
    BPREQI_ALLOLDFIELDS             = 0x01ff,
    
    // Flags below this point belong to BP_REQUEST_INFO2
    BPREQI_VENDOR                   = 0x0200,
    BPREQI_CONSTRAINT               = 0x0400,
    BPREQI_TRACEPOINT               = 0x0800,

    BPREQI_ALLFIELDS                = 0x0fff,
}
alias DWORD enum_BPREQI_FIELDS;
alias DWORD BPREQI_FIELDS;

struct _BP_REQUEST_INFO
{
    BPREQI_FIELDS dwFields;
    GUID guidLanguage;
    BP_LOCATION bpLocation;
    IDebugProgram2 pProgram;
    BSTR bstrProgramName;
    IDebugThread2 pThread;
    BSTR bstrThreadName;
    BP_CONDITION bpCondition;
    BP_PASSCOUNT bpPassCount;
    BP_FLAGS dwFlags;
}
alias _BP_REQUEST_INFO BP_REQUEST_INFO;

struct _BP_REQUEST_INFO2
{
    BPREQI_FIELDS dwFields;
    GUID guidLanguage;
    BP_LOCATION bpLocation;
    IDebugProgram2 pProgram;
    BSTR bstrProgramName;
    IDebugThread2 pThread;
    BSTR bstrThreadName;
    BP_CONDITION bpCondition;
    BP_PASSCOUNT bpPassCount;
    BP_FLAGS dwFlags;

    // guidVector may be NULL while guidLanguage is non-NULL
    // This means use all matching languages, regardless of vendor
    // for beining this breakpoint.
    GUID guidVendor;
    // The constraint associated with this breakpoint (may be NULL)
    BSTR bstrConstraint;
    // The tracepoint associated with this breakpoint (may be NULL)
    BSTR bstrTracepoint;
}
alias _BP_REQUEST_INFO2 BP_REQUEST_INFO2;

// ------------------------------------------------------------------
// IDebugBreakpointRequest2

const GUID IID_IDebugBreakpointRequest2 = IDebugBreakpointRequest2.iid;

interface IDebugBreakpointRequest2 : IUnknown
{
    static const GUID iid = { 0x6015fd18,0x8257,0x4df3,[ 0xac,0x42,0xf0,0x74,0xde,0xdd,0x4c,0xbd ] };
    HRESULT GetLocationType(
        /+[out]+/ BP_LOCATION_TYPE* pBPLocationType);

    HRESULT GetRequestInfo(
        in BPREQI_FIELDS dwFields,
        /+[out]+/ BP_REQUEST_INFO* pBPRequestInfo);
};

struct tagCHECKSUM_DATA
{
    DWORD ByteCount;
    /+[size_is(ByteCount)]+/ BYTE* pBytes;
}
alias tagCHECKSUM_DATA CHECKSUM_DATA;

// ------------------------------------------------------------------
// IDebugBreakpointChecksumRequest2
//
// Get this via QI from an IDebugBreakpointRequest2.
const GUID IID_IDebugBreakpointChecksumRequest2 = IDebugBreakpointChecksumRequest2.iid;

interface IDebugBreakpointChecksumRequest2 : IUnknown
{
    static const GUID iid = { 0x0EA91CF7,0x8542,0x4780,[ 0x8D,0x6B,0x7B,0xD6,0x86,0xCD,0x24,0x71 ] };
    // get the checksum based on the specified algorithm
    // pChecksumData->pBytes is allocated by the callee, and should be freed by the caller with CoTaskMemFree
    HRESULT GetChecksum(in GUID* guidAlgorithm, 
        /+[out]+/ CHECKSUM_DATA* pChecksumData);

    HRESULT IsChecksumEnabled(/+[out]+/ BOOL* pfChecksumEnabled);
};

// ------------------------------------------------------------------
// IDebugBreakpointRequest3

const GUID IID_IDebugBreakpointRequest3 = IDebugBreakpointRequest3.iid;

interface IDebugBreakpointRequest3 : IDebugBreakpointRequest2
{
    static const GUID iid = { 0x5C18A5FE,0x7150,0x4e66,[ 0x82,0x46,0x27,0xBF,0xB0,0xE7,0xBF,0xD9 ] };
    HRESULT GetRequestInfo2(
        in  BPREQI_FIELDS dwFields,
        /+[out]+/ BP_REQUEST_INFO2 * bBPRequestInfo);
};

// ------------------------------------------------------------------
// Breakpoint resolution stuff

struct _BP_RESOLUTION_CODE
{
    IDebugCodeContext2    pCodeContext;
}
alias _BP_RESOLUTION_CODE BP_RESOLUTION_CODE;

enum /+ enum_BP_RES_DATA_FLAGS+/ : DWORD 
{
    // The data breakpoint is being emulated
    // (rather than done via hardware)
    BP_RES_DATA_EMULATED        = 0x0001,
}
alias DWORD enum_BP_RES_DATA_FLAGS;
alias DWORD BP_RES_DATA_FLAGS;

struct _BP_RESOLUTION_DATA
{
    BSTR bstrDataExpr;
    BSTR bstrFunc;
    BSTR bstrImage;
    BP_RES_DATA_FLAGS dwFlags;
}
alias _BP_RESOLUTION_DATA BP_RESOLUTION_DATA;
    
union BP_RESOLUTION_LOCATION /+switch(BP_TYPE bpType) bpResLocation +/ {
    /+[case BPT_CODE:]+/
        BP_RESOLUTION_CODE bpresCode;

    /+[case BPT_DATA:]+/
        BP_RESOLUTION_DATA bpresData;

    /+[default:]+/
        int    unused; };

enum /+ enum_BPRESI_FIELDS+/ : DWORD 
{
    BPRESI_BPRESLOCATION    = 0x0001,
    BPRESI_PROGRAM            = 0x0002,
    BPRESI_THREAD            = 0x0004,

    BPRESI_ALLFIELDS        = 0xffffffff,
}
alias DWORD enum_BPRESI_FIELDS;
alias DWORD BPRESI_FIELDS;

struct _BP_RESOLUTION_INFO
{
    BPRESI_FIELDS dwFields;
    BP_RESOLUTION_LOCATION bpResLocation;
    IDebugProgram2 pProgram;
    IDebugThread2 pThread;
}
alias _BP_RESOLUTION_INFO BP_RESOLUTION_INFO;

// ------------------------------------------------------------------
// IDebugBreakpointResolution2

const GUID IID_IDebugBreakpointResolution2 = IDebugBreakpointResolution2.iid;

interface IDebugBreakpointResolution2 : IUnknown
{
    static const GUID iid = { 0xb7e66f28,0x035a,0x401a,[ 0xaf,0xc7,0x2e,0x30,0x0b,0xd2,0x97,0x11 ] };
    HRESULT GetBreakpointType(
        /+[out]+/ BP_TYPE* pBPType);
        
    HRESULT GetResolutionInfo(
        in BPRESI_FIELDS dwFields,
        /+[out]+/ BP_RESOLUTION_INFO* pBPResolutionInfo);
};

// ------------------------------------------------------------------
// Error breakpoint stuff

enum /+ enum_BP_ERROR_TYPE+/ : DWORD 
{
    BPET_NONE               = 0x00000000,

    BPET_TYPE_WARNING       = 0x00000001,
    BPET_TYPE_ERROR         = 0x00000002,

    BPET_SEV_HIGH           = 0x0F000000,
    BPET_SEV_GENERAL        = 0x07000000,
    BPET_SEV_LOW            = 0x01000000,

    BPET_TYPE_MASK          = 0x0000ffff,
    BPET_SEV_MASK           = 0xffff0000,

    // Use these contants for describing general warnings and errors
    BPET_GENERAL_WARNING    = BPET_SEV_GENERAL | BPET_TYPE_WARNING,
    BPET_GENERAL_ERROR      = BPET_SEV_GENERAL | BPET_TYPE_ERROR,

    BPET_ALL                = 0xffffffff,
}
alias DWORD enum_BP_ERROR_TYPE;
alias DWORD BP_ERROR_TYPE;

enum /+ enum_BPERESI_FIELDS+/ : DWORD 
{
    BPERESI_BPRESLOCATION   = 0x0001,
    BPERESI_PROGRAM         = 0x0002,
    BPERESI_THREAD          = 0x0004,
    BPERESI_MESSAGE         = 0x0008,
    BPERESI_TYPE            = 0x0010,

    BPERESI_ALLFIELDS       = 0xffffffff,
}
alias DWORD enum_BPERESI_FIELDS;
alias DWORD BPERESI_FIELDS;

struct _BP_ERROR_RESOLUTION_INFO
{
    BPERESI_FIELDS dwFields;
    BP_RESOLUTION_LOCATION bpResLocation;
    IDebugProgram2 pProgram;
    IDebugThread2 pThread;
    BSTR bstrMessage;
    BP_ERROR_TYPE dwType;
}
alias _BP_ERROR_RESOLUTION_INFO BP_ERROR_RESOLUTION_INFO;

// ------------------------------------------------------------------
// IDebugErrorBreakpointResolution2

const GUID IID_IDebugErrorBreakpointResolution2 = IDebugErrorBreakpointResolution2.iid;

interface IDebugErrorBreakpointResolution2 : IUnknown
{
    static const GUID iid = { 0x603aedf8,0x9575,0x4d30,[ 0xb8,0xca,0x12,0x4d,0x1c,0x98,0xeb,0xd8 ] };
    HRESULT GetBreakpointType(
        /+[out]+/ BP_TYPE* pBPType);
        
    HRESULT GetResolutionInfo(
        in BPERESI_FIELDS dwFields,
        /+[out]+/ BP_ERROR_RESOLUTION_INFO* pErrorResolutionInfo);
};

// ------------------------------------------------------------------
// IDebugBoundBreakpoint2

const GUID IID_IDebugBoundBreakpoint2 = IDebugBoundBreakpoint2.iid;

interface IDebugBoundBreakpoint2 : IUnknown
{
    static const GUID iid = { 0xd533d975,0x3f32,0x4876,[ 0xab,0xd0,0x6d,0x37,0xfd,0xa5,0x63,0xe7 ] };

    HRESULT GetPendingBreakpoint(
        /+[out]+/ IDebugPendingBreakpoint2 * ppPendingBreakpoint);

    HRESULT GetState(
        /+[out]+/ BP_STATE* pState);

    HRESULT GetHitCount(
        /+[out]+/ DWORD* pdwHitCount);

    HRESULT GetBreakpointResolution(
        /+[out]+/ IDebugBreakpointResolution2 * ppBPResolution);

    HRESULT Enable(
        in BOOL fEnable);

    HRESULT SetHitCount(
        in DWORD dwHitCount);

    HRESULT SetCondition(
        in BP_CONDITION bpCondition);

    HRESULT SetPassCount(
        in BP_PASSCOUNT bpPassCount);

    HRESULT Delete();
}
enum /+ enum_BP_STATE+/ : DWORD 
{
        BPS_NONE        = 0x0000,
        BPS_DELETED        = 0x0001,
        BPS_DISABLED    = 0x0002,
        BPS_ENABLED        = 0x0003,
}
alias DWORD enum_BP_STATE;
alias DWORD BP_STATE;;

// ------------------------------------------------------------------
// IDebugBoundBreakpoint3

const GUID IID_IDebugBoundBreakpoint3 = IDebugBoundBreakpoint3.iid;

interface IDebugBoundBreakpoint3 : IUnknown
{
    static const GUID iid = { 0x60f49115,0xce92,0x4f96,[ 0x8d,0x0a,0x81,0xcc,0xca,0xe4,0xab,0x77 ] };
    HRESULT SetTracepoint(
        in LPCOLESTR bpBstrTracepoint, 
        in BP_FLAGS bpFlags    // only BP_FLAG_DONT_STOP is supported
        );
};

// ------------------------------------------------------------------
// IDebugPendingBreakpoint2

const GUID IID_IDebugPendingBreakpoint2 = IDebugPendingBreakpoint2.iid;

interface IDebugPendingBreakpoint2 : IUnknown
{
    static const GUID iid = { 0x6e215ef3,0xe44c,0x44d1,[ 0xb7,0xba,0xb2,0x40,0x1f,0x7d,0xc2,0x3d ] };

    HRESULT CanBind(
        /+[out]+/ IEnumDebugErrorBreakpoints2 * ppErrorEnum);

    HRESULT Bind();

    HRESULT GetState(
        /+[out]+/ PENDING_BP_STATE_INFO* pState);

    HRESULT GetBreakpointRequest(
        /+[out]+/ IDebugBreakpointRequest2 * ppBPRequest);

    HRESULT Virtualize(
        in BOOL fVirtualize);

    HRESULT Enable(
        in BOOL fEnable);

    HRESULT SetCondition(
        in BP_CONDITION bpCondition);

    HRESULT SetPassCount(
        in BP_PASSCOUNT bpPassCount);

    HRESULT EnumBoundBreakpoints(
        /+[out]+/ IEnumDebugBoundBreakpoints2 * ppEnum);

    HRESULT EnumErrorBreakpoints(
        in BP_ERROR_TYPE bpErrorType,
        /+[out]+/ IEnumDebugErrorBreakpoints2 * ppEnum);

    HRESULT Delete();
}
enum /+ enum_PENDING_BP_STATE+/ : DWORD 
{
        PBPS_NONE            = 0x0000,
        PBPS_DELETED        = 0x0001,
        PBPS_DISABLED        = 0x0002,
        PBPS_ENABLED        = 0x0003,
}
alias DWORD enum_PENDING_BP_STATE;
alias DWORD PENDING_BP_STATE;
enum /+ enum_PENDING_BP_STATE_FLAGS+/ : DWORD 
{
        PBPSF_NONE            = 0x0000,
        PBPSF_VIRTUALIZED    = 0x0001,
}
alias DWORD enum_PENDING_BP_STATE_FLAGS;
alias DWORD PENDING_BP_STATE_FLAGS;
struct _tagPENDING_BP_STATE_INFO
{
        PENDING_BP_STATE state;
        PENDING_BP_STATE_FLAGS flags;
}
alias _tagPENDING_BP_STATE_INFO PENDING_BP_STATE_INFO;;

// ------------------------------------------------------------------
// IDebugPendingBreakpoint3

const GUID IID_IDebugPendingBreakpoint3 = IDebugPendingBreakpoint3.iid;

interface IDebugPendingBreakpoint3 : IDebugPendingBreakpoint2
{
    static const GUID iid = { 0x96643d32,0x2624,0x479a,[ 0x9f,0x1a,0x25,0xd0,0x20,0x30,0xdd,0x3b ] };
    HRESULT GetErrorResolutionInfo(
        in BPERESI_FIELDS dwFields,
        /+[out]+/ BP_ERROR_RESOLUTION_INFO* pErrorResolutionInfo);
};

// ------------------------------------------------------------------
// IDebugErrorBreakpoint2

const GUID IID_IDebugErrorBreakpoint2 = IDebugErrorBreakpoint2.iid;

interface IDebugErrorBreakpoint2 : IUnknown
{
    static const GUID iid = { 0x74570ef7,0x2486,0x4089,[ 0x80,0x0c,0x56,0xe3,0x82,0x9b,0x5c,0xa4 ] };
    HRESULT GetPendingBreakpoint(
        /+[out]+/ IDebugPendingBreakpoint2 * ppPendingBreakpoint);

    HRESULT GetBreakpointResolution(
        /+[out]+/ IDebugErrorBreakpointResolution2 * ppErrorResolution);
};

// ------------------------------------------------------------------
// IDebugExpression2
const GUID IID_IDebugExpression2 = IDebugExpression2.iid;

interface IDebugExpression2 : IUnknown
{
    static const GUID iid = { 0xf7473fd0,0x7f75,0x478d,[ 0x8d,0x85,0xa4,0x85,0x20,0x4e,0x7a,0x2d ] };

    HRESULT EvaluateAsync(
        in EVALFLAGS dwFlags,
        // pExprCallback must be NULL in V8 and above
        /+[in]+/ IDebugEventCallback2 pExprCallback);

    HRESULT Abort();

    HRESULT EvaluateSync(
        in EVALFLAGS dwFlags,
        in DWORD dwTimeout,
        // pExprCallback must be NULL in V8 and above
        /+[in]+/ IDebugEventCallback2 pExprCallback,
        /+[out]+/ IDebugProperty2 * ppResult);
}
enum /+ enum_EVALFLAGS+/ : DWORD 
{
        // the return value is interesting
        EVAL_RETURNVALUE            = 0x0002,
        // don't allow side effects
        EVAL_NOSIDEEFFECTS            = 0x0004,
        // stop on breakpoints
        EVAL_ALLOWBPS                = 0x0008,
        // allow error reporting to the host
        EVAL_ALLOWERRORREPORT        = 0x0010,
        // evaluate any functions as address (instead of invoking the function)
        EVAL_FUNCTION_AS_ADDRESS    = 0x0040,
        // don't allow function/property evaluation
        EVAL_NOFUNCEVAL                = 0x0080,
        // don't allow events
        EVAL_NOEVENTS                = 0x1000,
        // design-time expression evaluation
        EVAL_DESIGN_TIME_EXPR_EVAL  = 0x2000,
        // Allow implicit variable creation
        EVAL_ALLOW_IMPLICIT_VARS    = 0x4000
}
alias DWORD enum_EVALFLAGS;
alias DWORD EVALFLAGS;;

// ------------------------------------------------------------------
// IDebugModule2
const GUID IID_IDebugModule2 = IDebugModule2.iid;

interface IDebugModule2 : IUnknown
{
    static const GUID iid = { 0x0fc1cd9a,0xb912,0x405c,[ 0xa0,0x4c,0x43,0xce,0x02,0xcd,0x7d,0xf2 ] };

    HRESULT GetInfo(
        in MODULE_INFO_FIELDS dwFields,
        /+[out]+/ MODULE_INFO* pInfo);
    
    HRESULT ReloadSymbols_Deprecated(
        /+[ ptr]+/ in LPCOLESTR pszUrlToSymbols,
        /+[out]+/ BSTR* pbstrDebugMessage);
}
enum /+ enum_MODULE_FLAGS+/ : DWORD 
{
        MODULE_FLAG_NONE        = 0x0000,
        MODULE_FLAG_SYSTEM        = 0x0001,
        MODULE_FLAG_SYMBOLS        = 0x0002,
        MODULE_FLAG_64BIT        = 0x0004,
         
        //
        // If the engine knows a module about optimizations it needs to set
        // either of these flags, if it does not the module window will assume
        // it does not
        //
         
        MODULE_FLAG_OPTIMIZED    = 0x0008,
        MODULE_FLAG_UNOPTIMIZED    = 0x0010
}
alias DWORD enum_MODULE_FLAGS;
alias DWORD MODULE_FLAGS;
enum /+ enum_MODULE_INFO_FIELDS+/ : DWORD 
{
        MIF_NONE                = 0x0000,
        MIF_NAME                = 0x0001,
        MIF_URL                    = 0x0002,
        MIF_VERSION                = 0x0004,
        MIF_DEBUGMESSAGE        = 0x0008,
        MIF_LOADADDRESS            = 0x0010,
        MIF_PREFFEREDADDRESS    = 0x0020,
        MIF_SIZE                = 0x0040,
        MIF_LOADORDER            = 0x0080,
        MIF_TIMESTAMP            = 0x0100,
        MIF_URLSYMBOLLOCATION    = 0x0200,
        MIF_FLAGS                = 0x0400,

        MIF_ALLFIELDS            = 0x07ff,
}
alias DWORD enum_MODULE_INFO_FIELDS;
alias DWORD MODULE_INFO_FIELDS;
struct _tagMODULE_INFO
{
        MODULE_INFO_FIELDS dwValidFields;
        BSTR m_bstrName;
        BSTR m_bstrUrl;
        BSTR m_bstrVersion;
        BSTR m_bstrDebugMessage;
        UINT64 m_addrLoadAddress;
        UINT64 m_addrPreferredLoadAddress;
        DWORD m_dwSize;
        DWORD m_dwLoadOrder;
        FILETIME m_TimeStamp;
        BSTR m_bstrUrlSymbolLocation;
        MODULE_FLAGS m_dwModuleFlags;
}
alias _tagMODULE_INFO MODULE_INFO;;

// ------------------------------------------------------------------
// IDebugModule3
const GUID IID_IDebugModule3 = IDebugModule3.iid;

interface IDebugModule3 : IDebugModule2
{
    static const GUID iid = { 0x245F9D6A,0xE550,0x404d,[ 0x82,0xF1,0xFD,0xB6,0x82,0x81,0x60,0x7A ] };

    HRESULT GetSymbolInfo(
        in SYMBOL_SEARCH_INFO_FIELDS dwFields,
        /+[out]+/ MODULE_SYMBOL_SEARCH_INFO* pInfo);
    
    // LoadSymbols will use the current symbol path to search for
    // symbols.  The updated IDebugModule3 is sent in an IDebugSymbolSearchEvent2
    HRESULT LoadSymbols();

    // Returns whether module is user or not
    HRESULT IsUserCode(
        /+[out]+/ BOOL *pfUser);

    // Sets user status of module
    HRESULT SetJustMyCodeState(
        in BOOL fIsUserCode);
}
enum /+ enum_SYMBOL_SEARCH_INFO_FIELDS+/ : DWORD 
{
        SSIF_NONE                = 0x0000,
        SSIF_VERBOSE_SEARCH_INFO= 0x0001
}
alias DWORD enum_SYMBOL_SEARCH_INFO_FIELDS;
alias DWORD SYMBOL_SEARCH_INFO_FIELDS;
struct _tagSYMBOL_SEARCH_INFO
{
        // Details of where symbols were searched for and the result
        SYMBOL_SEARCH_INFO_FIELDS dwValidFields;
        BSTR bstrVerboseSearchInfo;
}
alias _tagSYMBOL_SEARCH_INFO MODULE_SYMBOL_SEARCH_INFO;

//
// IDebugSourceServerModule
//
// QI from IDebugModule2 
//
const GUID IID_IDebugSourceServerModule = IDebugSourceServerModule.iid;

interface IDebugSourceServerModule : IUnknown
{
    static const GUID iid = { 0x492e5541,0x215b,0x4f67,[ 0xad,0x73,0x20,0xf4,0x86,0x14,0x91,0x2e ] };
     // returns the source server data for the module
    // caller should free using CoTaskMemFree()
    HRESULT GetSourceServerData(
            /+[out]+/ ULONG* pDataByteCount, 
            /+[out, size_is (, *pDataByteCount)]+/ BYTE** ppData);
}

// ------------------------------------------------------------------
// IDebugModuleManaged
const GUID IID_IDebugModuleManaged = IDebugModuleManaged.iid;

interface IDebugModuleManaged : IUnknown
{
    static const GUID iid = { 0x232397F8,0xB232,0x479d,[ 0xB1,0xBB,0x2F,0x04,0x4C,0x70,0xA0,0xF9 ] };
    HRESULT GetMvid(
        /+[out]+/ GUID* mvid);
};

// ------------------------------------------------------------------
// IDebugDocument2
const GUID IID_IDebugDocument2 = IDebugDocument2.iid;

interface IDebugDocument2 : IUnknown
{
    static const GUID iid = { 0x1606dd73,0x5d5f,0x405c,[ 0xb4,0xf4,0xce,0x32,0xba,0xba,0x25,0x01 ] };
    HRESULT GetName(
        in GETNAME_TYPE gnType,
        /+[out]+/ BSTR* pbstrFileName);

    HRESULT GetDocumentClassId(
        /+[out]+/ CLSID* pclsid);
};

// ------------------------------------------------------------------
// IDebugDocumentText2
// #pragma warning(push)
// #pragma warning(disable:28718)
const GUID IID_IDebugDocumentText2 = IDebugDocumentText2.iid;

interface IDebugDocumentText2 : IDebugDocument2
{
    static const GUID iid = { 0x4b0645aa,0x08ef,0x4cb9,[ 0xad,0xb9,0x03,0x95,0xd6,0xed,0xad,0x35 ] };
    HRESULT GetSize(
        /+[in, out, ptr]+/ ULONG* pcNumLines,
        /+[in, out, ptr]+/ ULONG* pcNumChars);

    HRESULT GetText(
        in TEXT_POSITION pos,
        in ULONG cMaxChars,
        /+[out, length_is(*pcNumChars), size_is(cMaxChars)]+/ WCHAR* pText,
        /+[out]+/ ULONG* pcNumChars);
};
// #pragma warning(pop)

// ------------------------------------------------------------------
// IDebugDocumentPosition2
const GUID IID_IDebugDocumentPosition2 = IDebugDocumentPosition2.iid;

interface IDebugDocumentPosition2 : IUnknown
{
    static const GUID iid = { 0xbdde0eee,0x3b8d,0x4c82,[ 0xb5,0x29,0x33,0xf1,0x6b,0x42,0x83,0x2e ] };
    HRESULT GetFileName(
        /+[out]+/ BSTR* pbstrFileName);

    HRESULT GetDocument(
        /+[out]+/ IDebugDocument2 * ppDoc);

    HRESULT IsPositionInDocument(
        /+[in]+/ IDebugDocument2 pDoc);

    HRESULT GetRange(
        /+[in, out, ptr]+/ TEXT_POSITION* pBegPosition,
        /+[in, out, ptr]+/ TEXT_POSITION* pEndPosition);
};

// ------------------------------------------------------------------
// IDebugDocumentPositionOffset2
const GUID IID_IDebugDocumentPositionOffset2 = IDebugDocumentPositionOffset2.iid;

interface IDebugDocumentPositionOffset2 : IUnknown
{
    static const GUID iid = { 0x037edd0f,0x8551,0x4f7f,[ 0x8c,0xa0,0x04,0xd9,0xe2,0x9f,0x53,0x2d ] };
    HRESULT GetRange(
        /+[in, out, ptr]+/ DWORD* pdwBegOffset,
        /+[in, out, ptr]+/ DWORD* pdwEndOffset);
};

// ------------------------------------------------------------------
// IDebugFunctionPosition2

const GUID IID_IDebugFunctionPosition2 = IDebugFunctionPosition2.iid;

interface IDebugFunctionPosition2 : IUnknown
{
    static const GUID iid = { 0x1ede3b4b,0x35e7,0x4b97,[ 0x81,0x33,0x02,0x84,0x5d,0x60,0x01,0x74 ] };
    HRESULT GetFunctionName(
        /+[out]+/ BSTR* pbstrFunctionName);

    HRESULT GetOffset(
        /+[in, out, ptr]+/ TEXT_POSITION* pPosition);
};

// ------------------------------------------------------------------
// IDebugDocumentTextEvents2
const GUID IID_IDebugDocumentTextEvents2 = IDebugDocumentTextEvents2.iid;

interface IDebugDocumentTextEvents2 : IUnknown
{
    static const GUID iid = { 0x33ec72e3,0x002f,0x4966,[ 0xb9,0x1c,0x5c,0xe2,0xf7,0xba,0x51,0x24 ] };

    HRESULT onDestroy();

    HRESULT onInsertText(
        in TEXT_POSITION pos,
        in DWORD dwNumToInsert);

    HRESULT onRemoveText(
        in TEXT_POSITION pos,
        in DWORD dwNumToRemove);

    HRESULT onReplaceText(
        in TEXT_POSITION pos,
        in DWORD dwNumToReplace);

    HRESULT onUpdateTextAttributes(
        in TEXT_POSITION pos,
        in DWORD dwNumToUpdate);

    HRESULT onUpdateDocumentAttributes(
        in TEXT_DOC_ATTR_2 textdocattr);
}
alias DWORD TEXT_DOC_ATTR_2;
const TEXT_DOC_ATTR_2 TEXT_DOC_ATTR_READONLY_2 = 0x00000001;;

// ------------------------------------------------------------------
// IDebugQueryEngine2

const GUID IID_IDebugQueryEngine2 = IDebugQueryEngine2.iid;

interface IDebugQueryEngine2 : IUnknown
{
    static const GUID iid = { 0xc989adc9,0xf305,0x4ef5,[ 0x8c,0xa2,0x20,0x89,0x8e,0x8d,0x0e,0x28 ] };
    HRESULT GetEngineInterface(
        /+[out]+/ IUnknown * ppUnk);
};

//-------------------------------------------------------------------
// IEEHostServices
const GUID IID_IEEHostServices = IEEHostServices.iid;

interface IEEHostServices : IUnknown
{
    static const GUID iid = { 0xBB7BE481,0xDA8F,0x4b9e,[ 0x89,0xCB,0x0A,0x8D,0xDE,0x6B,0xC5,0xD7 ] };
    HRESULT GetHostValue(
        in LPCOLESTR valueCatagory, 
        in LPCOLESTR valueKind, 
        /+[out]+/ VARIANT * result);
    HRESULT SetHostValue(
        in LPCOLESTR valueCatagory, 
        in LPCOLESTR valueKind,
        in VARIANT newValue);
};

//-------------------------------------------------------------------
// IDebugCustomViewer
const GUID IID_IDebugCustomViewer = IDebugCustomViewer.iid;

interface IDebugCustomViewer : IUnknown
{
    static const GUID iid = { 0x6306E526,0x9E02,0x4696,[ 0xBF,0xF9,0x48,0x33,0x8A,0x27,0xF8,0xAF ] };
    HRESULT DisplayValue(
        in HWND hwnd,                         // Parent window.
        in DWORD dwID,                        // ID for custom viewers that support more than one type.
        /+[in]+/ IUnknown  pHostServices,
        /+[in]+/ IDebugProperty3 pDebugProperty);
};

    const GUID IID_IEEDataStorage = IEEDataStorage.iid;

interface IEEDataStorage : IUnknown
{
    static const GUID iid = { 0xDCF1F227,0xEC51,0x4680,[ 0x87,0x22,0xC8,0x79,0x6A,0x5F,0x34,0x83 ] };
        HRESULT GetSize(/+[out]+/ ULONG * size);
        HRESULT GetData(in ULONG dataSize, 
        /+[out]+/ ULONG * sizeGotten, 
        /+[out, size_is(dataSize), length_is(*sizeGotten)]+/ BYTE * data);
};

    const GUID IID_IPropertyProxyEESide = IPropertyProxyEESide.iid;

interface IPropertyProxyEESide : IUnknown
{
    static const GUID iid = { 0x579919D2,0x1B10,0x4584,[ 0x96,0x9C,0x3E,0x06,0x5B,0xD3,0xE2,0x2D ] };

        HRESULT InitSourceDataProvider(/+[out]+/ IEEDataStorage * dataOut);
        HRESULT GetManagedViewerCreationData (/+[out]+/ BSTR * assemName, 
        /+[out]+/ IEEDataStorage * assemBytes, 
        /+[out]+/ IEEDataStorage * assemPdb, 
        /+[out]+/ BSTR * className, 
        /+[out]+/ ASSEMBLYLOCRESOLUTION * alr, 
        /+[out]+/ BOOL * replacementOk);
        HRESULT GetInitialData(/+[out]+/ IEEDataStorage * dataOut);
        HRESULT CreateReplacementObject(/+[in]+/ IEEDataStorage  dataIn, 
        /+[out]+/ IEEDataStorage * dataOut);
        HRESULT InPlaceUpdateObject(/+[in]+/ IEEDataStorage  dataIn, 
        /+[out]+/ IEEDataStorage * dataOut);
        HRESULT ResolveAssemblyReference(in LPCOLESTR assemName, in GETASSEMBLY flags, 
        /+[out]+/ IEEDataStorage * assemBytes, 
        /+[out]+/ IEEDataStorage * assemPdb, 
        /+[out]+/ BSTR * assemLocation, 
        /+[out]+/ ASSEMBLYLOCRESOLUTION * alr);
}
enum /+ enum_ASSEMBLYLOCRESOLUTION+/ : DWORD 
{
            ALR_NAME = 0x0,
            ALR_USERDIR = 0x1,
            ALR_SHAREDDIR = 0x2,
            ALR_REMOTEDIR = 0x4,
            ALR_ERROR = 0x8,
            ALR_BYTES = 0x10,
}
alias DWORD enum_ASSEMBLYLOCRESOLUTION;
alias DWORD ASSEMBLYLOCRESOLUTION;
enum /+ enum_GETASSEMBLY+/ : DWORD 
{
            GA_BYTES = 0x1 ,
            GA_PDBBYTES = 0x2,
            GA_NAME = 0x4,
            GA_FLAGS = 0x8,
}
alias DWORD enum_GETASSEMBLY;
alias DWORD GETASSEMBLY;;

    const GUID IID_IPropertyProxyProvider = IPropertyProxyProvider.iid;

interface IPropertyProxyProvider : IUnknown
{
    static const GUID iid = { 0x30E6C90E,0x757E,0x48cf,[ 0x8D,0xB8,0x20,0xB0,0x61,0xAF,0xBB,0xAE ] };
        HRESULT GetPropertyProxy(in DWORD dwID, 
        /+[out]+/ IPropertyProxyEESide * proxy);
};

    const GUID IID_IManagedViewerHost = IManagedViewerHost.iid;

interface IManagedViewerHost : IUnknown
{
    static const GUID iid = { 0x5968D43D,0xD21E,0x437c,[ 0x9C,0x71,0x77,0xC5,0x2C,0x3E,0x28,0x7A ] };
        HRESULT CreateViewer(in ULONG hwnd, /+[in]+/ IUnknown  hostServices, /+[in]+/ IPropertyProxyEESide  property);
};

    const GUID IID_IEELocalObject = IEELocalObject.iid;

interface IEELocalObject : IUnknown
{
    static const GUID iid = { 0x44F8F85F,0x5514,0x49a3,[ 0x81,0x73,0x6F,0x9C,0x9F,0x1C,0x48,0x32 ] };
        HRESULT SetCallback(IDebugSettingsCallback2  pCallback);
};

    const GUID IID_IEEAssemblyRefResolveComparer = IEEAssemblyRefResolveComparer.iid;

interface IEEAssemblyRefResolveComparer : IUnknown
{
    static const GUID iid = { 0x6F1A544C,0xE69E,0x4a52,[ 0x9E,0xA1,0x25,0xC8,0x97,0xB0,0x5B,0xEF ] };
        HRESULT CompareRef(in DWORD cookieFirst, in DWORD cookieSecond, in DWORD cookieTarget, 
        /+[out]+/ BOOL * firstIsBetter);
};

    const GUID IID_IEEAssemblyRef = IEEAssemblyRef.iid;

interface IEEAssemblyRef : IUnknown
{
    static const GUID iid = { 0xAAD20A0E,0x9CD9,0x40ab,[ 0x91,0xB9,0x3C,0x19,0x43,0x56,0x2C,0x84 ] };
        HRESULT GetName(/+[out]+/ BSTR * bstr);
        HRESULT GetVersion(/+[out]+/ USHORT * major, 
        /+[out]+/ USHORT * minor, 
        /+[out]+/ USHORT * build, 
        /+[out]+/ USHORT * revision);
        HRESULT GetCulture(/+[out]+/ BSTR * bstr);
        HRESULT GetPublicKey(/+[out]+/ BSTR * key);
};

    const GUID IID_IEEHelperObject = IEEHelperObject.iid;

interface IEEHelperObject : IUnknown
{
    static const GUID iid = { 0x4A3BCDE5,0x5F66,0x4cc8,[ 0x9F,0xA0,0x14,0x27,0x5C,0xCE,0xE6,0x88 ] };

        HRESULT InitCache(IEEAssemblyRefResolveComparer  pResolver);

        HRESULT GetTargetClass(in LPCOLESTR name, in DWORD assemblyCookie, 
        /+[out]+/ DWORD * cookie, 
        /+[out]+/ ULONG * valueAttrCount, 
        /+[out]+/ ULONG * viewerAttrCount, 
        /+[out]+/ ULONG * visualizerAttrCount);
        HRESULT GetTargetAssembly(in LPCOLESTR name, 
        /+[out]+/ DWORD * cookie);

        HRESULT GetAssembly(in DWORD assemblyCookie, GETASSEMBLY flags, 
        /+[out]+/ ASSEMBLYFLAGS * flagsOut, 
        /+[out]+/ BSTR * name, 
        /+[out]+/ IEEDataStorage * assemBytes, 
        /+[out]+/ IEEDataStorage * pdbBytes);

        HRESULT GetHostAssembly(GETASSEMBLY flags, 
        /+[out]+/ IEEDataStorage * assemBytes, 
        /+[out]+/ IEEDataStorage * pdbBytes);

        HRESULT GetValueAttributeProps(in DWORD classCookie, in ULONG ordinal, 
        /+[out]+/ BSTR * targetedAssembly, 
        /+[out]+/ DWORD * assemLocation, 
        /+[out]+/ BSTR * name, 
        /+[out]+/ BSTR * value, 
        /+[out]+/ BSTR * type);
        HRESULT GetViewerAttributeProps(in DWORD classCookie, in ULONG ordinal, 
        /+[out]+/ BSTR * targetedAssembly, 
        /+[out]+/ DWORD * assemLocation, 
        /+[out]+/ BSTR * className, 
        /+[out]+/ DWORD * classAssemLocation);
        HRESULT GetVisualizerAttributeProps(in DWORD classCookie, in ULONG ordinal, 
        /+[out]+/ BSTR * targetedAssembly, 
        /+[out]+/ DWORD * assemLocation, 
        /+[out]+/ BSTR * displayClassName, 
        /+[out]+/ DWORD * displayClassAssemLocation, 
        /+[out]+/ BSTR * proxyClassName, 
        /+[out]+/ DWORD * proxyClassAssemLocation, 
        /+[out]+/ BSTR * description, 
        /+[out]+/ ULONG * uiType);
        HRESULT GetAssemblyRefForCookie(in DWORD cookie, 
        /+[out]+/ IEEAssemblyRef * ppAssemRef);
}
enum /+ enum_ASSEMBLYFLAGS+/ : DWORD 
{
            ASMF_USERDIR = 0x1,
            ASMF_SHAREDDIR = 0x2,
}
alias DWORD enum_ASSEMBLYFLAGS;
alias DWORD ASSEMBLYFLAGS;;

// ------------------------------------------------------------------
// IDebugExceptionCallback2
const GUID IID_IDebugExceptionCallback2 = IDebugExceptionCallback2.iid;

interface IDebugExceptionCallback2 : IUnknown
{
    static const GUID iid = { 0x6f5cfda4,0x47d3,0x4a90,[ 0xa8,0x82,0x14,0x42,0x72,0x37,0xbc,0xee ] };
    // S_OK indicates that we should stop
    HRESULT QueryStopOnException(
        /+[in]+/ IDebugProcess2 pProcess,
        /+[in]+/ IDebugProgram2 pProgram,
        /+[in]+/ IDebugThread2 pThread,
        /+[in]+/ IDebugExceptionEvent2 pEvent);
};

// ------------------------------------------------------------------
// IEnumDebugProcesses2
const GUID IID_IEnumDebugProcesses2 = IEnumDebugProcesses2.iid;

interface IEnumDebugProcesses2 : IUnknown
{
    static const GUID iid = { 0x96c74ef4,0x185d,0x4f9a,[ 0x8a,0x43,0x4d,0x27,0x23,0x75,0x8e,0x0a ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugProcess2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugProcesses2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPrograms2
const GUID IID_IEnumDebugPrograms2 = IEnumDebugPrograms2.iid;

interface IEnumDebugPrograms2 : IUnknown
{
    static const GUID iid = { 0x8d14bca6,0x34ce,0x4efe,[ 0xac,0x7e,0x0a,0xbc,0x61,0xda,0xdb,0x20 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugProgram2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugPrograms2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugThreads2
const GUID IID_IEnumDebugThreads2 = IEnumDebugThreads2.iid;

interface IEnumDebugThreads2 : IUnknown
{
    static const GUID iid = { 0x0d30dc12,0xc4f8,0x433d,[ 0x9f,0xcc,0x9f,0xf1,0x17,0xe5,0xe5,0xf4 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugThread2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugThreads2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugStackFrames2
const GUID IID_IEnumDebugStackFrames2 = IEnumDebugStackFrames2.iid;

interface IEnumDebugStackFrames2 : IUnknown
{
    static const GUID iid = { 0xcd39102b,0x4b69,0x4495,[ 0x8f,0x29,0xe0,0xb2,0x5c,0x4a,0x88,0x55 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugStackFrame2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugStackFrames2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);

    HRESULT GetIndex(
        /+[in]+/ IDebugStackFrame2 pStackFrame,
        /+[in, out]+/ ULONG* pIndex);
};

// ------------------------------------------------------------------
// IEnumDebugCodeContexts2
const GUID IID_IEnumDebugCodeContexts2 = IEnumDebugCodeContexts2.iid;

interface IEnumDebugCodeContexts2 : IUnknown
{
    static const GUID iid = { 0xad47a80b,0xeda7,0x459e,[ 0xaf,0x82,0x64,0x7c,0xc9,0xfb,0xaa,0x50 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugCodeContext2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugCodeContexts2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugBoundBreakpoints2

const GUID IID_IEnumDebugBoundBreakpoints2 = IEnumDebugBoundBreakpoints2.iid;

interface IEnumDebugBoundBreakpoints2 : IUnknown
{
    static const GUID iid = { 0x0f6b37e0,0xfcfe,0x44d9,[ 0x91,0x12,0x39,0x4c,0xa9,0xb9,0x21,0x14 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugBoundBreakpoint2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugBoundBreakpoints2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPendingBreakpoints2

const GUID IID_IEnumDebugPendingBreakpoints2 = IEnumDebugPendingBreakpoints2.iid;

interface IEnumDebugPendingBreakpoints2 : IUnknown
{
    static const GUID iid = { 0x70d2dc1e,0x4dcc,0x4786,[ 0xa0,0x72,0x9a,0x3b,0x60,0x0c,0x21,0x6b ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugPendingBreakpoint2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugPendingBreakpoints2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugErrorBreakpoints2

const GUID IID_IEnumDebugErrorBreakpoints2 = IEnumDebugErrorBreakpoints2.iid;

interface IEnumDebugErrorBreakpoints2 : IUnknown
{
    static const GUID iid = { 0xe158f5aa,0x31fe,0x491b,[ 0xa9,0xf6,0xcf,0xf9,0x34,0xb0,0x3a,0x01 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugErrorBreakpoint2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugErrorBreakpoints2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugMachines2__deprecated
const GUID IID_IEnumDebugMachines2__deprecated = IEnumDebugMachines2__deprecated.iid;

interface IEnumDebugMachines2__deprecated : IUnknown
{
    static const GUID iid = { 0x61d986ec,0x1eac,0x46b6,[ 0x90,0xff,0x40,0x2a,0x00,0x8f,0x15,0xd1 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugCoreServer2 * rgelt,
        /+[in, out]+/ ULONG *pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugMachines2__deprecated *ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG *pcelt);
};

// #define EnumMachines_V7 EnumMachines__deprecated
// #define IEnumDebugMachines2_V7 IEnumDebugMachines2__deprecated
// #define IID_IEnumDebugMachines2_V7 IID_IEnumDebugMachines2__deprecated

// ------------------------------------------------------------------
// IEnumDebugExceptionInfo2
const GUID IID_IEnumDebugExceptionInfo2 = IEnumDebugExceptionInfo2.iid;

interface IEnumDebugExceptionInfo2 : IUnknown
{
    static const GUID iid = { 0x8e4bbd34,0xa2f4,0x41ef,[ 0x87,0xb5,0xc5,0x63,0xb4,0xad,0x6e,0xe7 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ EXCEPTION_INFO* rgelt,
        /+[in, out]+/ ULONG *pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugExceptionInfo2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugFrameInfo2
const GUID IID_IEnumDebugFrameInfo2 = IEnumDebugFrameInfo2.iid;

interface IEnumDebugFrameInfo2 : IUnknown
{
    static const GUID iid = { 0x98bbba48,0x4c4d,0x4fff,[ 0x83,0x40,0x60,0x97,0xbe,0xc9,0xc8,0x94 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ FRAMEINFO* rgelt,
        /+[in, out]+/ ULONG *pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugFrameInfo2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

const GUID IID_IEnumDebugSessionFrameInfo2 = IEnumDebugSessionFrameInfo2.iid;

interface IEnumDebugSessionFrameInfo2 : IEnumDebugFrameInfo2
{
    static const GUID iid = { 0xef7262c4,0x4a01,0x42a0,[ 0x86,0x58,0x93,0x26,0x67,0xb2,0x75,0x55 ] };

    HRESULT SetCachePriority(
        in SESSION_CACHE_PRIORITY cachePriority);
}
enum /+ enum_SESSION_CACHE_PRIORITY+/
{
        NORMAL_CACHE_PRIORITY = 0,
        HIGH_CACHE_PRIORITY = 1
}
alias int enum_SESSION_CACHE_PRIORITY;
alias int SESSION_CACHE_PRIORITY;;

// ------------------------------------------------------------------
// IEnumDebugFrameInfoFilter2
const GUID IID_IEnumDebugFrameInfoFilter2 = IEnumDebugFrameInfoFilter2.iid;

interface IEnumDebugFrameInfoFilter2 : IEnumDebugFrameInfo2
{
    static const GUID iid = { 0x6CD4FB40,0xF954,0x44e0,[ 0xB8,0xA5,0xA6,0x14,0x48,0x1E,0x08,0x31 ] };
    HRESULT CanFilter(
        /+[out]+/ BOOL *pfCanFilter);

    HRESULT IsFiltered(
        /+[out]+/ BOOL *pfIsFiltered);
}

// ------------------------------------------------------------------
// IEnumCodePaths2
const GUID IID_IEnumCodePaths2 = IEnumCodePaths2.iid;

interface IEnumCodePaths2 : IUnknown
{
    static const GUID iid = { 0x9b13f80d,0xcfc6,0x4b78,[ 0x81,0xef,0x1f,0x7c,0xc3,0x3f,0x76,0x39 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ CODE_PATH* rgelt,
        /+[in, out]+/ ULONG *pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumCodePaths2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugModules2
const GUID IID_IEnumDebugModules2 = IEnumDebugModules2.iid;

interface IEnumDebugModules2 : IUnknown
{
    static const GUID iid = { 0x4c4a2835,0x682e,0x4ce1,[ 0xae,0xbc,0x1e,0x6b,0x3a,0x16,0x5b,0x44 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugModule2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugModules2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPortSuppliers2
const GUID IID_IEnumDebugPortSuppliers2 = IEnumDebugPortSuppliers2.iid;

interface IEnumDebugPortSuppliers2 : IUnknown
{
    static const GUID iid = { 0x59c9dc99,0x3eff,0x4ff3,[ 0xb2,0x01,0x98,0xac,0xd0,0x1b,0x0d,0x87 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugPortSupplier2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugPortSuppliers2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPorts2
const GUID IID_IEnumDebugPorts2 = IEnumDebugPorts2.iid;

interface IEnumDebugPorts2 : IUnknown
{
    static const GUID iid = { 0xbc827c5e,0x99ae,0x4ac8,[ 0x83,0xad,0x2e,0xa5,0xc2,0x03,0x43,0x33 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ IDebugPort2 * rgelt,
        /+[in, out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugPorts2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugPropertyInfo2
const GUID IID_IEnumDebugPropertyInfo2 = IEnumDebugPropertyInfo2.iid;

interface IEnumDebugPropertyInfo2 : IUnknown
{
    static const GUID iid = { 0x6c7072c3,0x3ac4,0x408f,[ 0xa6,0x80,0xfc,0x5a,0x2f,0x96,0x90,0x3e ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ DEBUG_PROPERTY_INFO* rgelt,
        /+[out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugPropertyInfo2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IEnumDebugReferenceInfo2
const GUID IID_IEnumDebugReferenceInfo2 = IEnumDebugReferenceInfo2.iid;

interface IEnumDebugReferenceInfo2 : IUnknown
{
    static const GUID iid = { 0xe459dd12,0x864f,0x4aaa,[ 0xab,0xc1,0xdc,0xec,0xbc,0x26,0x7f,0x04 ] };
    HRESULT Next(
        in ULONG celt,
        /+[out, size_is(celt), length_is(*pceltFetched)]+/ DEBUG_REFERENCE_INFO* rgelt,
        /+[out]+/ ULONG* pceltFetched);

    HRESULT Skip(
        in ULONG celt);

    HRESULT Reset();

    HRESULT Clone(
        /+[out]+/ IEnumDebugReferenceInfo2 * ppEnum);

    HRESULT GetCount(
        /+[out]+/ ULONG* pcelt);
};

// ------------------------------------------------------------------
// IDebugProcessQueryProperties
//   Extension interface implemented by IDebugProcess2 implementors.
//   Enable querying the information about the execution environment
//   of a process.
//
const GUID IID_IDebugProcessQueryProperties = IDebugProcessQueryProperties.iid;

interface IDebugProcessQueryProperties : IUnknown
{
    static const GUID iid = { 0x230A0071,0x62EF,0x4cae,[ 0xAA,0xC0,0x89,0x88,0xC3,0x70,0x24,0xBF ] };

    HRESULT QueryProperty(
        in PROCESS_PROPERTY_TYPE dwPropType,
        /+[out]+/ VARIANT *pvarPropValue);

    HRESULT QueryProperties(
        in ULONG celt,
        /+[ size_is (celt)]+/ in PROCESS_PROPERTY_TYPE *rgdwPropTypes,
        /+[out, size_is(celt)]+/ VARIANT *rgtPropValues);
}
enum /+ enum_PROCESS_PROPERTY_TYPE+/ : DWORD 
{
        // Return the command line as a VT_BSTR
        PROCESS_PROPERTY_COMMAND_LINE = 1,

        // Return the current directory as a VT_BSTR
        PROCESS_PROPERTY_CURRENT_DIRECTORY = 2,

        // Return the environment variavles as a VT_BSTR.
        // The format is:
        //   NAME1=VALUE1'\0'
        //   NAME2=VALUE2'\0'
        //   ...
        //   '\0'
        PROCESS_PROPERTY_ENVIRONMENT_VARIABLES = 3
}
alias DWORD enum_PROCESS_PROPERTY_TYPE;
alias DWORD PROCESS_PROPERTY_TYPE;;

// ------------------------------------------------------------------
// IDebugRemoteServer2 -- interface to an instance of msvsmon
const GUID IID_IDebugRemoteServer2 = IDebugRemoteServer2.iid;

interface IDebugRemoteServer2 : IUnknown
{
    static const GUID iid = { 0x3d3ce5c4,0x1508,0x4711,[ 0xa5,0xeb,0xf8,0x48,0xf6,0xe1,0x00,0x72 ] };

    HRESULT GetRemoteServerName(
        /+[out]+/ BSTR *pbstrName);

    HRESULT GetRemoteComputerInfo(
        /+[out]+/ COMPUTER_INFO * pInfo
        );

    HRESULT EnumRemoteProcesses(
        /+[out]+/ ENUMERATED_PROCESS_ARRAY * pProcessArray
        );

    HRESULT GetRemoteProcessInfo(
        in DWORD dwProcessId,
        in REMOTE_PROCESS_INFO_FIELDS Fields,
        /+[out]+/ REMOTE_PROCESS_INFO *pInfo
        );

    HRESULT CreateRemoteInstance(
        /+[ ptr]+/ in LPCWSTR szDll,
        in WORD wLangId,
        in CLSID* clsidObject,
        in IID* riid,
        /+[out, iid_is(riid)]+/ void **ppvObject);

    HRESULT WatchForRemoteProcessDestroy(
        /+[in]+/ IDebugPortEvents2 pCallback,
        /+[in]+/ IDebugProcess2 pProcess,
        /+[out]+/ WATCH_COOKIE *pWatchCookie);

    HRESULT CloseRemoteWatchCookie(
        in WATCH_COOKIE WatchCookie
        );

    HRESULT TerminateRemoteProcess(
        in DWORD dwProcessId
        );

    HRESULT LaunchRemoteProcess(
        in PROCESS_LAUNCH_INFO LaunchInfo,
        /+[out]+/ DWORD * pdwProcessId,
        /+[out]+/ RESUME_COOKIE * pResumeCookie);

    HRESULT CloseRemoteResumeCookie(
        in RESUME_COOKIE ResumeCookie);

    HRESULT DiagnoseRemoteWebDebuggingError(
        /+[ptr]+/ in LPCWSTR szUrl);
}
enum /+ enum_ENUMERATED_PROCESS_FLAGS+/ : DWORD 
{
        EPFLAG_SHOW_SECURITY_WARNING = 0x01,
        EPFLAG_SYSTEM_PROCESS        = 0x02
}
alias DWORD enum_ENUMERATED_PROCESS_FLAGS;
alias DWORD ENUMERATED_PROCESS_FLAGS;
enum /+ enum_REMOTE_PROCESS_FLAGS+/ : DWORD 
{
        // ENUMERATED_PROCESS_FLAGS can also be passed here

        RPFLAG_DEBUGGER_ATTACH       = 0x100,
        RPFLAG_SQL_LOADED            = 0x200,
        RPFLAG_CLR_LOADED            = 0x400,
        RPFLAG_PROCESS_WOW64         = 0x800,
}
alias DWORD enum_REMOTE_PROCESS_FLAGS;
alias DWORD REMOTE_PROCESS_FLAGS;
enum /+ enum_REMOTE_PROCESS_INFO_FIELDS+/ : DWORD 
{
        RPIF_TITLE                   = 0x01,
        RPIF_MODULE_PATH             = 0x02,
        RPIF_COMMAND_LINE            = 0x04,
        RPIF_CURRENT_DIRECTORY       = 0x08,
        RPIF_ENVIRONMENT_VARIABLES   = 0x10,
        RPIF_USER_NAME               = 0x20,
        RPIF_SESSION_ID              = 0x40,
        RPIF_ENUMERATED_FLAGS        = 0x80,
        RPIF_DEBUGGER_PRESENT_FLAGS  = 0x100,
        RPIF_PROGRAM_TYPE_FLAGS      = 0x200
}
alias DWORD enum_REMOTE_PROCESS_INFO_FIELDS;
alias DWORD REMOTE_PROCESS_INFO_FIELDS;
struct tagREMOTE_PROCESS_INFO
{
        REMOTE_PROCESS_INFO_FIELDS Fields;
        BSTR bstrTitle;
        BSTR bstrModulePath;
        BSTR bstrCommandLine;
        BSTR bstrCurrentDirectory;
        BSTR bstrEnvironmentVariables;
        BSTR bstrUserName;
        DWORD dwSessionId;
        REMOTE_PROCESS_FLAGS Flags;
}
alias tagREMOTE_PROCESS_INFO REMOTE_PROCESS_INFO;
struct tagENUMERATED_PROCESS
{
        DWORD dwProcessId;
        DWORD dwSessionId;
        BSTR bstrUserName;
        ENUMERATED_PROCESS_FLAGS dwProcessFlags;
}
alias tagENUMERATED_PROCESS ENUMERATED_PROCESS;
struct tagENUMERATED_PROCESS_ARRAY
{
        DWORD dwCount;
        /+[size_is(dwCount)]+/ ENUMERATED_PROCESS *Members;
}
alias tagENUMERATED_PROCESS_ARRAY ENUMERATED_PROCESS_ARRAY;
struct tagPROCESS_LAUNCH_INFO
{
        LPCOLESTR pszExe;
        /+[ptr]+/ LPCOLESTR pszArgs;
        /+[ptr]+/ LPCOLESTR pszDir;
        /+[ptr]+/ BSTR bstrEnv;
        BOOL fLaunchSuspended;
}
alias tagPROCESS_LAUNCH_INFO PROCESS_LAUNCH_INFO;
struct tagWATCH_COOKIE
{
        UINT64 val;
}
alias tagWATCH_COOKIE WATCH_COOKIE;
struct tagRESUME_COOKIE
{
        UINT64 val;
}
alias tagRESUME_COOKIE RESUME_COOKIE;;

// ------------------------------------------------------------------
// IDebugRemoteServerFactory2 - Implemented on Win9x by Msvsmon
const GUID IID_IDebugRemoteServerFactory2 = IDebugRemoteServerFactory2.iid;

interface IDebugRemoteServerFactory2 : IUnknown
{
    static const GUID iid = { 0x4a5af829,0xca32,0x4b01,[ 0xaa,0xe4,0x4c,0x53,0xd2,0x60,0xe7,0x5c ] };
    HRESULT CreateServer(
        /+[in]+/ IDebugSession2 pSession,
        /+[out]+/ IDebugRemoteServer2 *ppRemoteServer
        );
};

// ------------------------------------------------------------------
// IDebugProgramPublisher2 - Implemented by pdm.dll (coclass ProgramPublisher).
// This allows a script or third party program node to be published. These
// program nodes are then accessable from a debugger process using IDebugProgramProvider2
const GUID IID_IDebugProgramPublisher2 = IDebugProgramPublisher2.iid;

interface IDebugProgramPublisher2 : IUnknown
{
    static const GUID iid = { 0xa3dddf26,0x7792,0x4544,[ 0xa9,0xa4,0xd4,0xdf,0xb1,0x1c,0xd8,0xf3 ] };
    HRESULT PublishProgramNode(
        /+[in]+/  IDebugProgramNode2 pProgramNode);

    HRESULT UnpublishProgramNode(
        /+[in]+/  IDebugProgramNode2 pProgramNode);

    HRESULT PublishProgram(
        in  CONST_GUID_ARRAY Engines,
        /+[ ptr]+/ in LPCOLESTR szFriendlyName,
        /+[in]+/  IUnknown pDebuggeeInterface
        );

    HRESULT UnpublishProgram(
        /+[in]+/  IUnknown pDebuggeeInterface
        );

    HRESULT SetDebuggerPresent(
        in  BOOL fDebuggerPresent
        );
};

// ------------------------------------------------------------------
// IDebugProgramProvider2 - implemented by a 3rd party engine or by pdm.dll
// (coclass DebugProgramProvider). This allows the sdm to obtain program
// nodes for a running process.
const GUID IID_IDebugProgramProvider2 = IDebugProgramProvider2.iid;

interface IDebugProgramProvider2 : IUnknown
{
    static const GUID iid = { 0x1959530a,0x8e53,0x4e09,[ 0xad,0x11,0x1b,0x73,0x34,0x81,0x1c,0xad ] };

    HRESULT GetProviderProcessData(
        in  PROVIDER_FLAGS Flags,
        /+[in]+/  IDebugDefaultPort2 pPort,
        in  AD_PROCESS_ID processId,
        in  CONST_GUID_ARRAY EngineFilter,
        /+[out]+/ PROVIDER_PROCESS_DATA *pProcess);

    HRESULT GetProviderProgramNode(
        in  PROVIDER_FLAGS Flags,
        /+[in]+/  IDebugDefaultPort2 pPort,
        in  AD_PROCESS_ID processId,
        in GUID* guidEngine,
        in  UINT64 programId,
        /+[out]+/ IDebugProgramNode2 *ppProgramNode);

    HRESULT WatchForProviderEvents(
        in  PROVIDER_FLAGS Flags,
        /+[in]+/  IDebugDefaultPort2 pPort,
        in  AD_PROCESS_ID processId,
        in  CONST_GUID_ARRAY EngineFilter,
        in GUID* guidLaunchingEngine,
        /+[in]+/  IDebugPortNotify2 pEventCallback);

    HRESULT SetLocale(
        in WORD wLangID);
}
enum /+ enum_PROVIDER_FLAGS+/ : DWORD 
{
        PFLAG_NONE                     = 0x00,    // no flags
        PFLAG_REMOTE_PORT              = 0x01,    // asking for programs on a different machine then devenv
        PFLAG_DEBUGGEE                 = 0x02,    // the process is curently being debugged by this devenv
        PFLAG_ATTACHED_TO_DEBUGGEE     = 0x04,    // devenv is attached to the process (didn't launch it)
        PFLAG_REASON_WATCH             = 0x08,    // we are starting to watch for events
        PFLAG_GET_PROGRAM_NODES        = 0x10,    // want the 'ProgramNodes' field
        PFLAG_GET_IS_DEBUGGER_PRESENT  = 0x20
}
alias DWORD enum_PROVIDER_FLAGS;
alias DWORD PROVIDER_FLAGS;
enum /+ enum_PROVIDER_FIELDS+/ : DWORD 
{
        PFIELD_PROGRAM_NODES           = 0x01,
        PFIELD_IS_DEBUGGER_PRESENT     = 0x02
}
alias DWORD enum_PROVIDER_FIELDS;
alias DWORD PROVIDER_FIELDS;
struct tagPROGRAM_NODE_ARRAY
{
        DWORD dwCount;
        /+[size_is(dwCount)]+/ IDebugProgramNode2 * Members;
}
alias tagPROGRAM_NODE_ARRAY PROGRAM_NODE_ARRAY;
struct tagPROVIDER_PROCESS_DATA
{
        PROVIDER_FIELDS      Fields;
        PROGRAM_NODE_ARRAY   ProgramNodes;
        BOOL                 fIsDebuggerPresent;
}
alias tagPROVIDER_PROCESS_DATA PROVIDER_PROCESS_DATA;;

// ------------------------------------------------------------------
// IDebugProviderProgramNode2 - implemented by a 3rd party engine or by pdm.dll.
// This interface is implemented in pdm.dll in the debugger process. It allows
// an engine to retieve an interface from the program node running in the debuggee
// process.
const GUID IID_IDebugProviderProgramNode2 = IDebugProviderProgramNode2.iid;

interface IDebugProviderProgramNode2 : IUnknown
{
    static const GUID iid = { 0xafdba726,0x047a,0x4b83,[ 0xb8,0xc7,0xd8,0x12,0xfe,0x9c,0xaa,0x5c ] };
    HRESULT UnmarshalDebuggeeInterface(
        in IID* riid,
        /+[out, iid_is(riid)]+/ void **ppvObject);
};

// IDebugFirewallConfigurationCallback2 - implemented by vsdebug, and the SDM (port object). 
// This will determine if the Windows Firewall is blocking DCOM, and then take an 
// appropriate action
const GUID IID_IDebugFirewallConfigurationCallback2 = IDebugFirewallConfigurationCallback2.iid;

interface IDebugFirewallConfigurationCallback2 : IUnknown
{
    static const GUID iid = { 0xba3288db,0x224a,0x4fd6,[ 0xa3,0x7e,0x64,0xe7,0xab,0xe9,0xc4,0xa1 ] };
    // Try and configure the firewall (if neccessary) so that the debugger can
    // act as a DCOM server. 
    // Possible return values are S_OK and E_FIREWALL_USER_CANCLED
    HRESULT EnsureDCOMUnblocked();
};

// This informs the UI before we do an unsafe attach. This allows the UI to prompt
// the user to decide if the attach should proceed
const GUID IID_IDebugAttachSecurityCallback2 = IDebugAttachSecurityCallback2.iid;

interface IDebugAttachSecurityCallback2 : IUnknown
{
    static const GUID iid = { 0xa19e7faf,0xcb6f,0x43ba,[ 0xac,0x16,0xbd,0xe9,0x82,0x3d,0x6d,0xd1 ] };
    HRESULT OnUnsafeAttach(/+[in]+/ IDebugProcess2 pProcess);
};

// ------------------------------------------------------------------

version(all) /* #ifndef AD7_NO_LIB */ {
/+[
    uuid(d191c0d7-4c8b-4a15-a7b3-862dcd8daefb)
]+/ /+ library AD2Lib +/
    //import sdk.port.stdole2;
    //import win32.stdole2;

    const GUID CLSID_SDMServer = SDMServer.iid;

interface SDMServer
{
    static const GUID iid = { 0x5eb7d9f7,0xaf21,0x400e,[ 0xa2,0xc4,0x7f,0xd6,0x39,0x6f,0x86,0x41 ] };
        /+
        /+[default]+/+/ /+ interface IDebugSession2; +/
    };

    version(pp_ifdef) /* #ifdef DEBUG */ {
    alias MsMachineDebugManager_V7_DEBUG MsMachineDebugManager_V7;
    alias CLSID_MsMachineDebugManager_V7_DEBUG CLSID_MsMachineDebugManager_V7;
    } else {

    alias MsMachineDebugManager_V7_RETAIL MsMachineDebugManager_V7;
    alias CLSID_MsMachineDebugManager_V7_RETAIL CLSID_MsMachineDebugManager_V7;
    } 

    const GUID CLSID_MsMachineDebugManager_V7_RETAIL = MsMachineDebugManager_V7_RETAIL.iid;

interface MsMachineDebugManager_V7_RETAIL
{
    static const GUID iid = { 0x73b25ffd,0xf501,0x437b,[ 0x8b,0x11,0x7f,0x0d,0xe3,0x83,0x96,0x4f ] };
        /+
        /+[default]+/+/ /+ interface IDebugMachine2_V7; +/
    };

    const GUID CLSID_MsMachineDebugManager_V7_DEBUG = MsMachineDebugManager_V7_DEBUG.iid;

interface MsMachineDebugManager_V7_DEBUG
{
    static const GUID iid = { 0x05e1b201,0x493d,0x4678,[ 0xbb,0xcb,0x18,0xd9,0xca,0xf5,0xc0,0xa9 ] };
        /+
        /+[default]+/+/ /+ interface IDebugMachine2_V7; +/
    };

    version(pp_ifdef) /* #ifdef DEBUG */ {
    alias MDMUtilServer_V7_DEBUG MDMUtilServer_V7;
    alias CLSID_MDMUtilServer_V7_DEBUG CLSID_MDMUtilServer_V7;
    } else {

    alias MDMUtilServer_V7_RETAIL MDMUtilServer_V7;
    alias CLSID_MDMUtilServer_V7_RETAIL CLSID_MDMUtilServer_V7;
    } 

    const GUID CLSID_MDMUtilServer_V7_RETAIL = MDMUtilServer_V7_RETAIL.iid;

interface MDMUtilServer_V7_RETAIL
{
    static const GUID iid = { 0xb20e899d,0xb079,0x479d,[ 0xa4,0xdc,0x10,0xf7,0x58,0xd9,0xcd,0x9a ] };
        /+
        /+[default]+/+/ /+ interface IDebugMDMUtil2_V7; +/
    };

    const GUID CLSID_MDMUtilServer_V7_DEBUG = MDMUtilServer_V7_DEBUG.iid;

interface MDMUtilServer_V7_DEBUG
{
    static const GUID iid = { 0x89370a13,0x3977,0x4e7d,[ 0xae,0xa0,0x0a,0x97,0x51,0xae,0x59,0x6b ] };
        /+
        /+[default]+/+/ /+ interface IDebugMDMUtil2_V7; +/
    };

    const GUID CLSID_ProgramPublisher = ProgramPublisher.iid;

interface ProgramPublisher
{
    static const GUID iid = { 0xd04d550d,0x1ea8,0x4e37,[ 0x83,0x0e,0x70,0x0f,0xea,0x44,0x76,0x88 ] };
        /+
        /+[default]+/+/ /+ interface IDebugProgramPublisher2; +/
    };

    const GUID CLSID_MsProgramProvider = MsProgramProvider.iid;

interface MsProgramProvider
{
    static const GUID iid = { 0x170ec3fc,0x4e80,0x40ab,[ 0xa8,0x5a,0x55,0x90,0x0c,0x7c,0x70,0xde ] };
        /+
        /+[default]+/+/ /+ interface IDebugProgramProvider2; +/
    };
;
} 

